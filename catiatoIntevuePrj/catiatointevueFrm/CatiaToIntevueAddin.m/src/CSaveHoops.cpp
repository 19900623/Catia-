//===================================================================
// COPYRIGHT HUSTCAD 2018/12/04
//===================================================================
// CSaveHoops.cpp
// Header definition of class CSaveHoops
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2018/12/04 Creation: Code generated by the 3DS wizard
//===================================================================
#include "CATIPLMcomponent.h"
#include "CATIMmiPrtContainer.h"
#include "CATIPLMNavRepReference.h"
#include "CATIPsiRepresentationLoadMode.h"
#include "CATIMmiMechanicalFeature.h"

#include "CATIAlias.h"
#include "CATIAlias.h"
#include "CATUnicodeString.h"
#include "CATString.h"
#include "CAT3DFaceGP.h"


// Mathematics
#include "CATMath.h"                   // Mathematical base function
#include "CATMathPoint.h"              // Mathematical point
#include "CATMathPlane.h"
#include "CATMathAxis.h"               // Axis system
#include "CATMathConstant.h"           // for the CATPI constant
//#include "CATSoftwareConfiguration.h"  // Configuration of the operator
#include "CATMathTransformation.h"


// GeometricObjects
//#include "CATGeoFactory.h"             // Geometry factory
#include "CATCGMContainerMngt.h"       // Geometry factory management
#include "CATPlane.h"
#include "CATCylinder.h"
#include "CATSphere.h"                 // Geometric sphere                
#include "CATLine.h"                   // Geometric line
#include "CATCircle.h"
#include "CATPoint.h"
#include "CATSurLimits.h"              // Limits on a surface
#include "CATGeometry.h"
#include "CATEdgeCurve.h"
#include "CATCrvLimits.h"
//#include "CATIAProduct.h"
#include "CATIAParameters.h"
#include "CATIAParameter.h"
#include "CATIAParameterSet.h"
// Topology
#include "CATVertex.h"
#include "CATEdge.h"
#include "CATFace.h"                   // Face
#include "CATBody.h"                   // Body
#include "CATTopData.h"                // TopData of an operator

// TopologicalOperators
//#include "CATTopSkin.h"                // to create the body to tessellate

// Tessellation
#include "CATICGMBodyTessellator.h"        // Body tessellator
#include "CATCGMTessPointIter.h"          // Result of the tessellation: the points
#include "CATCGMTessStripeIter.h"         // Result of the tessellation: the stripe
#include "CATCGMTessPolyIter.h"           // Result of the tessellation: the polygons
#include "CATCGMTessTrianIter.h"          // Result of the tessellation: the triangles 
#include "CATCGMTessFanIter.h"            // Result of the tessellation: the triangles 

#include "CATIPartRequest.h"
#include "CATIVisProperties.h"
#include "CATIBodyRequest.h"
#include "CATVisPropertiesValues.h"
#include "CATIPLMNavOccurrence.h"
#include "CATIPLMNavRepInstance.h"

#include "CATIAdpType.h"


#include "CATIPsiRepresentationReference.h"
#include "CATIPLMRepInstances.h"
#include "CATIPrdIterator.h"
#include "CATI3DGeometricalElement.h"
#include "CATIMmiUseGeometricalElement.h"
#include "CATIMmiUseBRepAccess.h"
#include "CATMmiUseServicesFactory.h"
#include "CATIMmiUseBRepDecodeServices.h"
#include "CATIPLMProducts.h"
#include "CATFrmEditor.h"
#include "CATIDftDrawing.h"
#include "CATDftDrawingPLMServices.h"
#include "CATDieImportExportServices.h"
#include "CATIAdpPLMIdentificator.h"

#include "CATIAttributesDescription.h"
#include "CATCkeObjectAttrReadServices.h"
#include "CATICkeObject.h"
#include "CATCkePLMNavPublicServices.h"
#include "CATI3DGeoVisu.h"

#include "CATIValue.h"
#include "CATRep.h"
#include "CAT3DRep.h"
#include "CAT3DGeomRep.h"
#include "CATSurfacicRep.h"
#include "CAT3DBagRep.h"

#include "CATListPtrCATIPLMNavEntity.h"
#include "CATListPtrCATIPLMNavInstance.h"
#include "CATListPtrCATIPLMNavOccurrence.h"
#include "CATListPtrCATIPLMNavReference.h"
#include "CATListPtrCATIPLMNavRepInstance.h"
#include "CATListPtrCATIPLMNavRepReference.h"
#include "CATIPLMNavReference.h"

#ifndef _WINDOWS_
#include <afxwin.h>
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#else
#undef  _WINDOWS_
#include <afxwin.h>
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#define  _WINDOWS_

#endif

#include "IvFile.h"
#include "..\..\..\include\IvConvertAsm.h"
#include "..\..\..\include\IvConverter.h"


#include "..\..\..\include\IvgFile.h"
//#include "..\..\..\..\InteVueFoCatiaDll\InteVueForCatiaHeader.h"
//#pragma comment (lib,"..\\..\\..\\..\\lib_x64\\InteVueFoCatiaDll.lib")


//#include "..\..\..\..\DxfConvertorDll\DxfConvertordll.h"
#pragma comment (lib,"..\\..\\..\\..\\lib_x64\\IvConverter_vc10.lib")
//#pragma comment (lib,"..\\..\\..\\..\\..\\lib\\DxfConvertorDll.lib")
#pragma comment (lib,"shlwapi.lib")
#pragma comment (lib,"..\\..\\..\\..\\lib_x64\\IvgIODll_x64.lib")
#include "CSaveHoops.h"
#include "CComFun.h"
#include <vector>
#include "CATVisManager.h"
using namespace std;
//double gChord=1.0;
BOOL g_bExportAttribut;//是否输出文件属性
BOOL g_bExportCore;        //输出零件的转动贯量、重心
BOOL g_bExportMass;//输出零件或装配质量属性BOOL
BOOL g_bSameWithOldDirctory;//轻量化文件是否在同一目录
BOOL g_bAutoJudgeToGenerateInteVueFile; //是否自动判断需要生成轻量化文件 TRUE自动判断，否则重新生成轻量化文件

//-----------------------------------------------------------------------------
// CSaveHoops : constructor
//-----------------------------------------------------------------------------
CSaveHoops::CSaveHoops()
{
//
//TODO: Add the constructor code here
//
}

//-----------------------------------------------------------------------------
// CSaveHoops : destructor
//-----------------------------------------------------------------------------

CSaveHoops::~CSaveHoops()
{
//
// TODO: Place code here.
//
}

void testRef(CATIPLMComponent * piPLMComponentOnPart)
{
	//CATIPLMNavRepReference * pIPLMNavRepReferenceOnCreatedRepRef = NULL;
	//if (NULL != piPLMComponentOnPart)
	//{
	//	piPLMComponentOnPart->QueryInterface(IID_CATIPLMNavRepReference, (void **)& pIPLMNavRepReferenceOnCreatedRepRef);
	//	piPLMComponentOnPart->Release();
	//	piPLMComponentOnPart = NULL;
	//}


	//CATIPLMNavEntity_var rep2 = piPLMComponentOnPart;
	//CATIPLMNavInstance_var rep3 = piPLMComponentOnPart;
	CATIPLMNavOccurrence_var rep1 = piPLMComponentOnPart;
	CATIPLMNavReference *opiReference=NULL;
	HRESULT rs=rep1-> GetRelatedReference(opiReference);
	if (SUCCEEDED(rs))
	{
     
		  CATIPLMNavRepReference *pIPLMNavRepReferenceOnCreatedRepRef=NULL ;
		  opiReference->QueryInterface(IID_CATIPLMNavRepReference, (void **)& pIPLMNavRepReferenceOnCreatedRepRef);
		  
		  CATIPLMComponent_var component=pIPLMNavRepReferenceOnCreatedRepRef;
		  CATIAdpPLMIdentificator *id;
		  CATIAdpPLMIdentificator *&pid=id;
		  component->GetAdpID(pid);
		//  CATVisManager* pVisManager = CATVisManager::GetVisManager(); 
		  CATIAdpPLMIdentificator const &pid1=*pid;
		//  CATRep* pRep1= pVisManager->BuildRep(pid1);



		  CATIMmiPrtContainer * piPartContainer = NULL ;
		  HRESULT rs1=pIPLMNavRepReferenceOnCreatedRepRef->RetrieveApplicativeContainer("CATPrtCont",IID_CATIMmiPrtContainer,(void **)&piPartContainer);

		  CATIMmiMechanicalFeature_var spMechFeatOnPart;
		  if ( NULL != piPartContainer) 
		  {
			  piPartContainer->GetMechanicalPart(spMechFeatOnPart);
		  }


		  CATIVisu * pIVisuOnRoot =NULL ;    
		  HRESULT rs2 = pIPLMNavRepReferenceOnCreatedRepRef->QueryInterface(IID_CATIVisu,
			  (void **) & pIVisuOnRoot);
		  if (pIVisuOnRoot!=NULL)
		  {
			  CATRep * pRep = pIVisuOnRoot->GiveRep();

		  }
	}



	CATIPLMNavRepInstance_var rep2 = piPLMComponentOnPart;
	CATIPLMNavRepReference_var rep3 = piPLMComponentOnPart;
	//CATIPLMNavReference_var rep7 = piPLMComponentOnPart;

	//CATIMmiPrtContainer * piPartContainer1 = NULL;
	/*rep1->RetrieveApplicativeContainer("CATPrtCont", IID_CATIMmiPrtContainer, (void **)&piPartContainer1);

	CATIMmiPrtContainer * piPartContainer2 = NULL;
	rep2->RetrieveApplicativeContainer("CATPrtCont", IID_CATIMmiPrtContainer, (void **)&piPartContainer2);

	CATIMmiPrtContainer * piPartContainer3 = NULL;
	rep3->RetrieveApplicativeContainer("CATPrtCont", IID_CATIMmiPrtContainer, (void **)&piPartContainer3);

	CATIMmiMechanicalFeature_var spMechFeatOnPart1;
	if ( NULL != piPartContainer1)
	{
		piPartContainer1->GetMechanicalPart(spMechFeatOnPart1);
	}

	CATIMmiMechanicalFeature_var spMechFeatOnPart2;
	if ( NULL != piPartContainer2)
	{
		piPartContainer2->GetMechanicalPart(spMechFeatOnPart2);
	}

	CATIMmiMechanicalFeature_var spMechFeatOnPart3;
	if ( NULL != piPartContainer3)
	{
		piPartContainer1->GetMechanicalPart(spMechFeatOnPart3);
	}*/

	//	CATI3DGeoVisu_var  pIVisuOnRoot = piPartContainer;
	//rc = spPart->QueryInterface(IID_CATI3DGeoVisu,(void **)& pIVisuOnRoot);
	  //  CATRep * pRep = pIVisuOnRoot.GiveRep();

}

//保存到hoops
void CSaveHoops::SaveToItnevue(CATIPLMComponent *pComponent)
{
//	testRef(pComponent);

	CComFun::InfoComponent(pComponent);
	//设置路径
	//CATFrmEditor * pEditor = CATFrmEditor::GetCurrentEditor();
	//CComFun::GetInputDirectory(NULL);


	if(CComFun::IsPart(pComponent)) //零件
	{

		//CComFun::ImportStepFile(_T("G:\\项目\\湖北\\701\\IPDE_20180926Send\\01PIPE.step"));
		SavePart(pComponent);
	}
	else if(CComFun::isAsm(pComponent)) //装配文件
	{
		SaveAsm(pComponent);
	}
	else if(CComFun::isDrawing(pComponent)) //工程图
	{
		SaveDrawing(pComponent);
	}
	else
	{
		AfxMessageBox(_T("未知的文件类型！"));
		return ;
	}
}
//保存为asm
void CSaveHoops::SaveAsm(CATIPLMComponent *pComponent)
{
	if(pComponent==NULL)
		return ;
	CATIPLMProducts_var pProducts=pComponent;
	if(pProducts==NULL_var)
		return ;
	//遍历子节点
	CATIPrdIterator *PrdIter=NULL;
	pProducts->Iterator(PrdIter);
	if(PrdIter==NULL)
		return ;

	CATUnicodeString usIntevueFile;
	usIntevueFile.BuildFromBSTR(CComFun::ToIntevueFile(pComponent).AllocSysString());
	CATUnicodeString usDisplayName;
	usDisplayName.BuildFromBSTR(CComFun::GetObjName(pComponent).AllocSysString());
	CIvConvertAsm asmConverter;
	asmConverter.SetFile(usIntevueFile.ConvertToChar(),usDisplayName.ConvertToChar());
	//写入属性
	CString strPropName;
	CString strTitle;
	CString strValue;	
	GetDocAttribute(pComponent,strPropName,strTitle,strValue);
	CATUnicodeString ustrTempPropName;
	ustrTempPropName.BuildFromBSTR(strPropName.AllocSysString());
	CATUnicodeString ustrTempTitle;
	ustrTempTitle.BuildFromBSTR(strTitle.AllocSysString());
	CATUnicodeString ustrTempValue;
	ustrTempValue.BuildFromBSTR(strValue.AllocSysString());
	asmConverter.WritePropSet("Parameters","参考",ustrTempPropName.ConvertToChar(),ustrTempTitle.ConvertToChar(),ustrTempValue.ConvertToChar());

	//遍历所有的子节点
	CATBaseUnknown_var pNext;
	while(SUCCEEDED(PrdIter->Next(pNext)))
	{
		CATIPrdObject_var pPrd=pNext;
		if(pPrd!=NULL_var)
		{
			if(pPrd->IsReference()) //这个是参考
			{
				//AfxMessageBox(_T("ref"));
			}
			else //这个是是实例，实际上所有的produt只能得到实例
			{
				//变换矩阵
				double dMatrix[16];
				CATIPLMProducts_var pInstance;
				pInstance=pNext;
				CComFun::GetInstanceTranf(pInstance,dMatrix);
				//父节点名
				CATUnicodeString usParentFullPath;
				usParentFullPath.BuildFromBSTR(CComFun::ToIntevueFile(pComponent).AllocSysString());

				CATUnicodeString usNodeName;
				CString strNodeName;
				strNodeName=CComFun::GetObjName((CATIPrdObject *)pPrd);
				//char cNodeName[100];
				//sprintf(cNodeName,"%s",strNodeName);
				usNodeName.BuildFromBSTR(strNodeName.AllocSysString());
				
				CATBaseUnknown *pChildRef=NULL;
				pPrd->GetReferenceObject(pChildRef);
				CATUnicodeString usType;
				CATUnicodeString usChildFullPath;
				if(pChildRef) //这个是
				{
					CATIPLMComponent *pComponent=NULL;
					pChildRef->QueryInterface(IID_CATIPLMComponent,(void **)&pComponent);
					usChildFullPath.BuildFromBSTR(CComFun::ToIntevueFile(pComponent).AllocSysString());
					if(CComFun::IsPart(pComponent))
					{
						SavePart(pComponent);
						usType="PRT";
					}
					else if(CComFun::isAsm(pComponent))
					{
						SaveAsm(pComponent);
						usType="ASM";
					}
				}
				double color[] = {-1, -1, -1};
				asmConverter.WriteChild_V2(usType.ConvertToChar(),usNodeName.ConvertToChar(),
					usChildFullPath.ConvertToChar(),usParentFullPath.ConvertToChar(),
					0x08000008, FALSE,dMatrix,color,FALSE,NULL,usNodeName.ConvertToChar());	
			}
		}
	}


}

//对存在多页的情况需要查找所有的dxf文件
BOOL FindDwgFile(CString strDxfFile,CStringList &strlistDxf)
{
	BOOL bFind=FALSE;
	CString strFilter;
	strFilter=strDxfFile.Left(strDxfFile.GetLength()-4)+"_*.dwg";
	CFileFind finder;
	BOOL bWorking = finder.FindFile(strFilter);
	while (bWorking)
	{
		bWorking = finder.FindNextFile();
		strlistDxf.AddTail(finder.GetFilePath ());
		bFind=TRUE;
	}   

	return bFind;
}

//另存二维工程图
void CSaveHoops::SaveDrawing(CATIPLMComponent *pComponent)
{
	//先输出dxf或dwg
	if(pComponent==NULL)
		return ;
	CString strDwgFileNameNoExt;
	strDwgFileNameNoExt=CComFun::GetLocalPath(pComponent);
	//先将dwg文件转换成dwg，然后在生成ivg
	CComFun::ExportDwg(pComponent,strDwgFileNameNoExt);
	CString strDwgFile;
	CString strIvgFile;
	strIvgFile=strDwgFileNameNoExt+_T(".ivg");
	strDwgFile=strDwgFileNameNoExt+_T(".dwg");

	CATUnicodeString ustrDwgFileName;
	ustrDwgFileName.BuildFromBSTR(strDwgFile.AllocSysString());

	CATUnicodeString ustrIvgFileName;
	ustrIvgFileName.BuildFromBSTR(strIvgFile.AllocSysString());

	char cIvgFileName[1000];
	char cDwgFileName[1000];
	sprintf(cIvgFileName,"%s",ustrIvgFileName.ConvertToChar());
	sprintf(cDwgFileName,"%s",ustrDwgFileName.ConvertToChar());
	
	//有几页sheet，将几页sheet合成一个ivg
	//获得dxf文件名
	if(PathFileExists(strDwgFile)) //只有一个文件
	{
		CIvgFile *pIvg = NULL;
		pIvg = ClassCreate_CIvgFile();
		pIvg->MWriteFileA(cIvgFileName,"","Catia","");	
		pIvg->MWritePageAttributeA(cDwgFileName,NULL,NULL);
		pIvg->saveIvgFile();
		ClassRelease_CIvgFile(pIvg);
		remove(cDwgFileName); //删除dxf文件	
	}
	else //如果有多个文件
	{
		//在当前目录中寻找所有的dxf文件。
		//AfxMessageBox(CString("目前还没有处理CATia中存在多页的情况"));
		BOOL bFind;
		CStringList strlistDxf;
		bFind=FindDwgFile(strDwgFile,strlistDxf);
		//char cSheetName[100];

		POSITION pos;
		pos=strlistDxf.GetHeadPosition();
		int i=0;
		if(strlistDxf.GetCount()<=0)
			return ;

		CIvgFile *pIvg = NULL;
		pIvg = ClassCreate_CIvgFile();
		pIvg->MWriteFileA(cIvgFileName,"","Catia","");	

		while(pos)
		{
			CString strTemp=strlistDxf.GetNext(pos);				
			//GetSheetName(strTemp,strIvdFileName,cSheetName);
			CATUnicodeString ustrTemp;
			ustrTemp.BuildFromWChar(strTemp);
			i++;

			pIvg->MWritePageAttributeA(ustrTemp.ConvertToChar(),NULL,NULL);

			//删除dxf文件
			remove(ustrTemp.ConvertToChar());
		}
		//MConvertDxfToIvdEnd(cIvdFileName);		
		pIvg->saveIvgFile();
		ClassRelease_CIvgFile(pIvg);

	}	
}


void CSaveHoops::SavePart(CATIPLMComponent *pComponent)
{
	if(pComponent==NULL)
		return ;

	if(CComFun::gbFromGraph)
	{
		SavePartFromGraph(pComponent);
		return ;
	}

	if(CComFun::gbOutputStep) //输出step文件
	{
		CString strLocalFileName;
		strLocalFileName=CComFun::GetLocalPath(pComponent);
		CComFun::ExportStep(pComponent,strLocalFileName);
	}

	CATIMmiPrtContainer *piPrtContainer=NULL;
	GetMechanicalContainer(pComponent,&piPrtContainer);
	HRESULT rc;
	//CATIMmiPrtContainer * piPrtContainer = NULL;

	////CATIPsiRepresentationReference_var pPsiRep=pComponent;

	//CATIPsiRepresentationLoadMode_var spLoadMode = pComponent;
	//if(NULL_var != spLoadMode) //这个如果为空的话，就不知道是怎么一回事了
	//		rc = spLoadMode -> ChangeLoadingMode (CATIPsiRepresentationLoadMode::EditMode);

	//

	//rc = pComponent -> QueryInterface (IID_CATIPLMNavRepReference, (void **)& piNavRepRef);

	//if(SUCCEEDED(rc) && (NULL != piNavRepRef)) //获得part的container
	//{
	//	rc = piNavRepRef -> RetrieveApplicativeContainer (CATUnicodeString("CATPrtCont"), IID_CATIMmiPrtContainer, (void **)& piPrtContainer);

	//	piNavRepRef -> Release();
	//	piNavRepRef = NULL ;
	//}
	if(piPrtContainer==NULL)
		return;
	CATIMmiMechanicalFeature_var spMechFeatOnPart ;
	piPrtContainer->GetMechanicalPart(spMechFeatOnPart); //得到part feature
	if(spMechFeatOnPart==NULL_var)
		return ;
	CATIPartRequest_var spPartAsRequest = spMechFeatOnPart ;
	if(spPartAsRequest==NULL_var)
		return ;
	CATListValCATBaseUnknown_var pListBodies;
	rc=spPartAsRequest->GetAllBodies(CATUnicodeString(""),pListBodies); //获得所有的bodies

	CString *strPropSetsName=NULL,*strPropSetsDisplayName=NULL;
	CStringList lstTitle, lstValue,lstDisplayName;
	int iSetsCount=0;
	//GetDocParameter(pPartDocument,iSetsCount,strPropSetsName,strPropSetsDisplayName,lstTitle,lstDisplayName,lstValue);
	GetDocAttribute(pComponent,lstTitle,lstDisplayName,lstValue);


	//如果catia模型的修改时间与ivp的修改时间一样，就直接退出
	CString catiaTime=CComFun::GetCatiaModifiedTime(pComponent);
	CString ivpName=CComFun::ToIntevueFile(pComponent);
	CString ivpTime;//秒数，距离1970年
	ivpTime.Format(_T("%d"),CComFun::GetIvpModifiedTime(ivpName));
	if (ivpTime==catiaTime)
	{
		return;
	}

	CATUnicodeString usIntevueFile;
	usIntevueFile.BuildFromBSTR(CComFun::ToIntevueFile(pComponent).AllocSysString());
	char cIntevueFile[1000];
	strcpy(cIntevueFile,usIntevueFile.ConvertToChar());
	API_InitConverter(cIntevueFile);


	CString strPropName=_T("参考");
	CString strXmlInfo; //记录为xml文件格式的属性信息；
	int iCount=1;
	strXmlInfo=WrtitAllAttributeInXmlString(iCount,&strPropName,&strPropName,&lstTitle,&lstDisplayName,&lstValue);
	CATUnicodeString ustrTemp;
	ustrTemp.BuildFromWChar(strXmlInfo);
	API_WriteInfo(ustrTemp.ConvertToChar(),strlen(ustrTemp.ConvertToChar()));


	if ( SUCCEEDED(rc) )  //依次处理所有的body
	{
		int iAllBodyCount=0;
		int nbbodies = pListBodies.Size();
		int iBodies =1 ;	  
		while ( (iBodies <= nbbodies) )
		{
			CATBaseUnknown_var spMainPartBody ;
			spMainPartBody = pListBodies[iBodies] ;
			iBodies++;
			CATGeometry_var pBody;
			pBody=spMainPartBody;
			if(pBody!=NULL)
			{
				CATMathBox bodyBox;
				CATMathPoint ioPoint;
				pBody->GetBoundingBox(bodyBox);
				if(!bodyBox.IsEmpty ())
				{
					CATMathPoint ioPoint;
					float box[6];
					bodyBox.GetLow(ioPoint);
					box[0] = float(ioPoint.GetX());
					box[1] = float(ioPoint.GetY());
					box[2] = float(ioPoint.GetZ());
					bodyBox.GetHigh(ioPoint);
					box[3] = float(ioPoint.GetX());
					box[4] = float(ioPoint.GetY());
					box[5] = float(ioPoint.GetZ());

					//去掉最大的一个面的信息,这里存在一个隐患问题
					if(fabs(box[0]-box[3])+fabs(box[1]-box[4])+	fabs(box[2]-box[5])>1500000.0)
						continue;					
				}
			}	
			

			if (  ( NULL_var == spMainPartBody) )
			{
				continue;
			}
			//判断体是否可见
			CATIVisProperties *pBodyVisProps = 0;
			rc= spMainPartBody->QueryInterface(IID_CATIVisProperties,
				(void**)&pBodyVisProps) ;			
			if ( SUCCEEDED(rc) )
			{                
				CATVisPropertiesValues visual;
				rc=pBodyVisProps->GetPropertiesAtt(visual, CATVPShow, CATVPGlobalType);
				if(SUCCEEDED(rc))
				{
					CATShowAttribut showAttrib;
					rc=visual.GetShowAttr(showAttrib);
					if(showAttrib==CATShowAttr)
					{						
					}
					else if(showAttrib==CATNoShowAttr)
					{					
						continue; //跳过
					}
					else if(showAttrib==CATPermanentShowAttr )
					{					
					}
					else if(showAttrib==CATInvisibleAttr)
					{					
						continue;
					}					
				}
			}

			//
			// 7-2 Retrieves the feature holding the result of the main body
			//     It's the first element of the list returned by GetResults
			//
			CString strBodyName;
			strBodyName=CComFun::GetObjName(spMainPartBody);
			CATIBodyRequest_var spMainPartBodyBodyRequest = spMainPartBody ;
			if ( NULL_var == spMainPartBodyBodyRequest )
			{
				continue;
			}

			CATLISTV(CATBaseUnknown_var) ListResult ;
			rc = spMainPartBodyBodyRequest->GetResults("",ListResult);
			int bodycount = ListResult.Size();
			if ( FAILED(rc) || (0 == bodycount ))
			{		
				continue;
			}
			iAllBodyCount++;

			//
			// 7-3 Retrieves a CATIGeometricalElement pointer on the feature result
			//
			CATIMmiUseGeometricalElement_var spFeatureResultGeomElem;
			for(int  i=1; i<=bodycount; i++ )
			{
				spFeatureResultGeomElem = ListResult[i];
				if ( NULL_var == spFeatureResultGeomElem )
				{
					//cout <<"Error, the feature result does not implement CATIGeometricalElement" << endl;
					continue;
					
				}
				if(GetBodyVisiblity(spFeatureResultGeomElem)==FALSE)
					continue;

				CATIVisProperties *pTempVisProps = 0;
				rc= spFeatureResultGeomElem->QueryInterface(IID_CATIVisProperties,
					(void**)&pTempVisProps) ;

				if(SUCCEEDED(rc))
				{
					CATVisPropertiesValues visualTemp;
					rc=pTempVisProps->GetPropertiesAtt(visualTemp, CATVPShow, CATVPGlobalType);
					if(SUCCEEDED(rc))
					{
						CATShowAttribut showAttribTemp;
						rc=visualTemp.GetShowAttr(showAttribTemp);
						if(showAttribTemp==CATShowAttr)
						{
							//AfxMessageBox(_T("1"));
						}
						else if(showAttribTemp==CATNoShowAttr)
						{
							//						AfxMessageBox(_T("2"));
							continue; //跳过
						}
						else if(showAttribTemp==CATPermanentShowAttr )
						{
							//	AfxMessageBox(_T("3"));
						}
						else if(showAttribTemp==CATInvisibleAttr)
						{
							//						AfxMessageBox(_T("4"));
							continue;
						}
					}
					//					int iTemp=0;
				}



				//
				// 7-4 Retrieves the CATBody associating with the feature result
				//
				CATBody_var spPartTopoBody;
				rc= spFeatureResultGeomElem->GetBodyResult(spPartTopoBody);
				if ( NULL_var == spPartTopoBody )
				{
					//cout <<"Error, the body returned by the GetSolid method is NULL" << endl;
					continue;
					//			return 1;
				}

				CATBody *piBody = spPartTopoBody;
				if (NULL==piBody)
				{
					continue;
					//			return (1);
				}
				char cSegmentName[1000];
				sprintf(cSegmentName,"body_%d_%d",iAllBodyCount,i);
				char cOption[1000];
				CString strOption;
				if(strBodyName.IsEmpty())
					strOption.Format(_T("isbody=true,bodyname='%s'"),cSegmentName);
				else
				{
					if(bodycount==1) //当只有一个体的时候可能无法分清楚对应的体；
						strOption.Format(_T("isbody=true,bodyname='%s'"),strBodyName);
					else
						strOption.Format(_T("isbody=true,bodyname='%s_%d'"),strBodyName,i);
				}

				if(WriteGeometrySet(piBody,spFeatureResultGeomElem)==FALSE) //先对只有点和线的body进行处理;
				{
					CATUnicodeString ustrOption;
					ustrOption.BuildFromWChar(strOption.AllocSysString());
					strcpy(cOption,ustrOption.ConvertToChar());
					API_OpenSegment(cSegmentName);
					API_SetUnicodeUserOptions(cOption);
					ConvertBodyToIntevue(piBody,spFeatureResultGeomElem);
					API_CloseSegment();
				}
			}
		}
	}
	API_TerminateConverter();
	//修改ivp的修改时间
	CComFun::SetIvpModifiedTime(catiaTime,ivpName);
}
//void SaveAsm(CATIPLMComponent *pComponent)
//{
//
//}
//void SaveDrawing(CATIPLMComponent *pComponent)
//{
//
//}

//CATUnicodeString CSaveHoops::GetObjName(CATBaseUnknown *pObj)
//{
//	if(pObj==NULL)
//		return NULL;
//	CATIAlias_var sAlias=pObj;
//	if(sAlias!=NULL_var)
//	{
//		CATUnicodeString usAlias = sAlias->GetAlias();
//		return usAlias;
//	}
//	return CATUnicodeString("");
//}

BOOL CSaveHoops::ConvertBodyToIntevue(CATBody *pBody,CATIMmiUseGeometricalElement_var spFeatureResultGeomElem)
{
	if(pBody==NULL)
		return FALSE;

	SetWeldingPointUserOption(pBody,spFeatureResultGeomElem);


	CATMathBox bodyBox;
	CATMathPoint ioPoint;
	pBody->GetBoundingBox(bodyBox);
	if(!bodyBox.IsEmpty ())
	{
		CATMathPoint ioPoint;
		float box[6];
		bodyBox.GetLow(ioPoint);
		box[0] = float(ioPoint.GetX());
		box[1] = float(ioPoint.GetY());
		box[2] = float(ioPoint.GetZ());
		bodyBox.GetHigh(ioPoint);
		box[3] = float(ioPoint.GetX());
		box[4] = float(ioPoint.GetY());
		box[5] = float(ioPoint.GetZ());

		//去掉最大的一个面的信息,这里存在一个隐患问题
		if(fabs(box[0]-box[3])+fabs(box[1]-box[4])+	fabs(box[2]-box[5])>1500000.0)
			return FALSE;					
	}


	int j,k;
	int rc;
	//double sag   = 0.1; //三角化的参数；
	CATICGMBodyTessellator * pTessellator = CATCGMCreateBodyTessellator(pBody,CComFun::gfChord);
	if (NULL==pTessellator)
	{				
		return FALSE; //三角化不成功；				
	}
	pTessellator -> Run();

	//-----------------------------------------------------------------------------
	// 4- Gets the results
	//-----------------------------------------------------------------------------
	CATBoolean isPlanar;
	CATCGMTessPointIter *    pVertices  = NULL;
	CATCGMTessStripeIter *   pStrips    = NULL;
	CATCGMTessFanIter *      pFans      = NULL;
	CATCGMTessPolyIter *     pPolygons  = NULL;
	CATCGMTessTrianIter *    pTriangles = NULL;

	float  (* aCoord)[3] = NULL;
	float  (* aNormal)[3] = NULL;
	int		* aNuStrips	 = NULL;
	int     * aNuPts     = NULL;
	float	box[6];
	int		flist_length = 0;
	int		*flist = NULL;
	int		flist_index = 0;
	int		size = 0;
	char	*buffer = NULL;


	// Retrieves all the body faces. 
	//
	CATCellHashTable *pHashtable;	
	pHashtable=pBody->GetAllCells();

	CATLISTP(CATCell) faces;
	pBody->GetAllCells( faces,2);
	int numberOfFaces = faces.Size();

	BOOL bHasBigFace=FALSE;
	for ( j=1 ; j<=numberOfFaces ; j++)
	{
		CATFace * piFace = (CATFace*) faces[j];

		//得到面包围盒
		const CATMathBox *faceBox;
		CATMathPoint ioPoint;
		faceBox = piFace->Get3DBoundingBox();
		if(faceBox->IsEmpty ())
			continue;

		faceBox->GetLow(ioPoint);
		box[0] = float(ioPoint.GetX());
		box[1] = float(ioPoint.GetY());
		box[2] = float(ioPoint.GetZ());
		faceBox->GetHigh(ioPoint);
		box[3] = float(ioPoint.GetX());
		box[4] = float(ioPoint.GetY());
		box[5] = float(ioPoint.GetZ());

		//去掉最大的一个面的信息,这里存在一个隐患问题
		if(fabs(box[0]-box[3])+fabs(box[1]-box[4])+	fabs(box[2]-box[5])>1500000.0)
		{
			bHasBigFace=TRUE;
			continue;					
		}


		// 
		// for each face, retrieve the tessellation results.
		//
		pTessellator -> GetFace(piFace,isPlanar,&pVertices,&pStrips,&pFans,&pPolygons,&pTriangles);

		//
		// vertices (in one shot)
		//
		CATLONG32 nbp;
		if(NULL != pVertices)
		{
			nbp=pVertices->GetNbPoint();
			aCoord = new float[nbp][3];
			aNormal = new float[nbp][3];
			pVertices->GetPointXyzAll(aCoord);
			pVertices->GetPointNorAll(aNormal);
		}

		// 三角形带
		CATLONG32 ioNbPtsAll = 0;
		CATLONG32 oNbStripsAll = 0;
		if( NULL != pStrips )
		{
			oNbStripsAll = pStrips->GetNbStri(ioNbPtsAll);
			flist_length = ( ioNbPtsAll - 2 * oNbStripsAll ) * 4;
			//				aNuStrips = new int[oNbStripsAll];
			//				aNuPts = new int[ioNbPtsAll];
			//				pStrips->GetStriAllNuPts(aNuStrips, aNuPts);
		}

		//孤立三角形
		CATLONG32 nNuIsoTiangles = 0;
		//			int ( * aNuTriPts)[3];
		if( NULL != pTriangles )
		{
			nNuIsoTiangles = pTriangles->GetNbTrian();
			flist_length += nNuIsoTiangles * 4;
			//				aNuTriPts = new int[nNuIsoTiangles][3];
			//				pTriangles->GetTrianAllNuPts(aNuTriPts);
		}

		//扇形三角形
		CATLONG32 nNuFans = 0;
		CATLONG32 nNuPts = 0;
		if( NULL != pFans )
		{
			nNuFans = pFans->GetNbFan(nNuPts);
			flist_length += ( nNuPts - 2 * nNuFans ) * 4;
		}

		flist = new int[flist_length];

		//
		// strips (one by one)
		//
		if(NULL != pStrips)
		{
			// size of the maximum allocation
			CATLONG32 nbs=0;
			while (0==(pStrips->IsExhausted()))
			{
				nbs=CATMax(nbs,pStrips->GetStriNbPts());
				pStrips->GoToNext();
			}
			//
			// allocation
			//
			if(nbs>0)
			{


				aNuPts=new int[nbs];
				//
				// from the beginning again to retrieve the results
				//
				pStrips->Reset();
				while (0==(pStrips->IsExhausted()))
				{	
					nbs=pStrips->GetStriNbPts();
					pStrips->GetStriNuPts(aNuPts);

					// interior lines of the strip
					for( k=0; k<nbs-2; k++ )
					{
						flist[flist_index] = 3;
						if( k%2 == 0 )
						{
							flist[flist_index+1] = aNuPts[k];
							flist[flist_index+2] = aNuPts[k+1];
							flist[flist_index+3] = aNuPts[k+2];
						}
						else
						{
							flist[flist_index+1] = aNuPts[k+1];
							flist[flist_index+2] = aNuPts[k];
							flist[flist_index+3] = aNuPts[k+2];
						}
						flist_index += 4;
					}
					pStrips->GoToNext();
				}
				delete [] aNuPts;
				aNuPts = NULL;
			}
		}

		//
		// isolated triangles (one by one)
		//
		if(NULL != pTriangles)
		{
			pTriangles->Reset();
			while (0==(pTriangles->IsExhausted()))
			{	
				int aNuP[3];
				pTriangles->GetTrianNuPts(aNuP);
				flist[flist_index] = 3;
				flist[flist_index+1] = aNuP[0];
				flist[flist_index+2] = aNuP[1];
				flist[flist_index+3] = aNuP[2];
				flist_index += 4;
				pTriangles->GoToNext();
			}
		}

		//
		// fans
		//
		if(NULL != pFans)
		{
			// size of the maximum allocation
			CATLONG32 nbs=0;
			while (0==(pFans->IsExhausted()))
			{
				//					cout << pFans->GetFanNbPts() << endl;
				nbs=CATMax(nbs,pFans->GetFanNbPts());
				pFans->GoToNext();
			}
			//
			// allocation
			//
			if(nbs>0)
			{


				aNuPts=new int[nbs];

				// from the beginning again to retrieve the results
				//
				pFans->Reset();
				while (0==(pFans->IsExhausted()))
				{	
					nbs=pFans->GetFanNbPts();

					pFans->GetFanNuPts(aNuPts);
					// 
					for( k=0; k<nbs-2; k++ )
					{
						flist[flist_index] = 3;
						flist[flist_index+1] = aNuPts[0];
						flist[flist_index+2] = aNuPts[k+1];
						flist[flist_index+3] = aNuPts[k+2];
						flist_index += 4;
					}

					pFans->GoToNext();
				}
				delete [] aNuPts;
				aNuPts = NULL;
			}
		}

		//得到面的颜色
		CATCell_var pCell ( piFace );
		//CATIMmiUseBRepAccess_var pBrep;
		CATIMmiUseBRepDecodeServices_var spBRepDecodeServices;
		CATMmiUseServicesFactory::CreateBRepDecodeServices(spBRepDecodeServices);
		//spBRepDecodeServices->DecodeCellInGeomElt(pBrep,pCell,spFeatureResultGeomElem);

		CATIMmiUseBRepAccess_var spBRepAccess;
		spBRepDecodeServices->DecodeCellInGeomElt(spBRepAccess,pCell,spFeatureResultGeomElem);
		


		double rgb[3];
		unsigned int r,g,b;
		rgb[0]=-1;
		rgb[1]=-1;
		rgb[2]=-1;

		if(spBRepAccess!=NULL_var)
		{

		CATIVisProperties *pBRepAccessAsGraphics = 0;
		rc= spBRepAccess->QueryInterface(IID_CATIVisProperties,
			(void**)&pBRepAccessAsGraphics) ;


		if ( SUCCEEDED(rc) )
		{                
			CATVisPropertiesValues color;
			pBRepAccessAsGraphics->GetPropertiesAtt(color, CATVPColor, CATVPMesh);
			color.GetColor(r, g, b);
			rgb[0] = r/255.0;
			rgb[1] = g/255.0;
			rgb[2] = b/255.0;
			pBRepAccessAsGraphics->Release();
			pBRepAccessAsGraphics = NULL ;
		}

		}

		//得到面的类型
		double root[3];
		double direct[3];
		double radius;
		CATMathPoint	ioOrigin;
		CATMathVector	ioNormal;
		CATMathAxis		ioMathAxis;
		CATOrientation  orient=CATOrientationPositive;
		CATSurface *pSurface = piFace->GetSurface();
		//orient=piFace->GetGeometryOrientation();
		if( pSurface->IsATypeOf(CATPlaneType) )
		{
			((CATPlane *)pSurface)->GetNormal( ioOrigin, ioNormal );
			ioOrigin.GetCoord(root);

			//CATSurParam oParam;
			//piFace->EstimateCenterParam(oParam);
			//piFace->EvalNormal(oParam,ioNormal);

			ioNormal.GetCoord(direct);
			//if(orient==CATOrientationNegative) //如果方向是反的则需要将面的法矢进行反向处理
			//{
			//	direct[0]=-direct[0];
			//	direct[1]=-direct[1];
			//	direct[2]=-direct[2];
			//	AfxMessageBox(_T("Neg"));
			//}
			//else if(orient==CATOrientationPositive)
			//{
			//	AfxMessageBox(_T("pos"));
			//}
			//else
			//{
			//	AfxMessageBox(_T("unkonw"));
			//}
			//API_WritePlaneToBuffer( root, direct, size, buffer );
		}
		else if( pSurface->IsATypeOf(CATCylinderType) )
		{
			radius = ((CATCylinder *)pSurface)->GetRadius();
			((CATElementarySurface *)pSurface)->GetAxis(ioMathAxis);
			ioMathAxis.GetOrigin(ioOrigin);
			ioMathAxis.GetThirdDirection(ioNormal);
			ioOrigin.GetCoord(root);
			ioNormal.GetCoord(direct);
			API_WriteCylinderToBuffer( root, direct, radius, size, buffer );
		}

		CATULONG32 pHandle;
		pHandle=piFace->GetPersistentTag();

		char cHandle[100];
		sprintf(cHandle,"%d",pHandle);
		
		API_WriteShellWithHandle( nbp, aCoord[0], aNormal[0], flist_length, flist, box, size, buffer, rgb,cHandle );

		flist_index = 0;

		if( size > 0 )
		{
			API_FreeBuffer(buffer);

			size = 0;
		}

		delete [] flist;
		flist = NULL;

		delete [] aCoord;
		aCoord = NULL;

		delete [] aNormal;
		aNormal = NULL;
	}

	//if(bHasBigFace)
	//	continue;
	// Retrieves all the body edges.
	//
	CATLISTP(CATCell) edges;
	pBody->GetAllCells( edges,1);
	int numberOfEdges = edges.Size();

	for ( j=1 ; j<=numberOfEdges ; j++)
	{
		CATEdge * piEdge = (CATEdge*) edges[j];

		// 
		// for each edge, retrieve the tessellation results.
		//
		CATLONG32 nPts;
		float *points;
		pTessellator->GetEdge(piEdge, nPts, &points);


		//得到边的几何
		CATEdgeCurve *pGeometry=piEdge->GetCurve();
		CATCurve *pCurve;
		double root[3];
		double dir[3];
		double radius;
		CATMathPoint ioOrigin;
		CATMathDirection ioDirection;
		CATMathPlane axis;

		rc= pGeometry->QueryInterface(IID_CATLine,(void**)&pCurve) ;
		if (SUCCEEDED(rc) )
		{
			if(pCurve->IsAKindOf("CATLine"))//直线
			{
				CATLine *pLine = (CATLine *)pCurve;
				pLine->GetOrigin(ioOrigin);
				pLine->GetDirection(ioDirection);
				ioOrigin.GetCoord(root);
				ioDirection.GetCoord(dir);
				API_WriteLineToBuffer( root, dir, size, buffer );
			}
			pCurve->Release();
			pCurve=NULL;
		}
		else if ( SUCCEEDED(pGeometry->QueryInterface(IID_CATCircle,( void**)&pCurve)) )
		{
			if(pCurve->IsAKindOf("CATCircle"))
			{
				CATCircle *pCircle =(CATCircle *)pCurve;
				radius=pCircle->GetRadius();
				axis = pCircle->GetAxis();
				axis.GetOrigin(ioOrigin);
				axis.GetNormal(ioDirection);
				ioOrigin.GetCoord(root);
				ioDirection.GetCoord(dir);
				API_WriteArcToBuffer( root, dir, radius, size, buffer );

			}
			pCurve->Release();
			pCurve=NULL;		
		}


		//得到线的颜色
		//CATCell_var pCell ( piEdge );
		//CATIBRepAccess_var spBRepAccess ( CATBRepDecode(pCell, spFeatureResultGeomElem) );
		//CATIVisProperties *pBRepAccessAsGraphics = 0;
		//rc= spBRepAccess->QueryInterface(IID_CATIVisProperties,
		//	(void**)&pBRepAccessAsGraphics) ;

		//unsigned int r,g,b;
		//double rgb[3];
		//if ( SUCCEEDED(rc) )
		//{                
		//	CATVisPropertiesValues color;
		//	pBRepAccessAsGraphics->GetPropertiesAtt(color, CATVPColor, CATVPMesh);
		//	color.GetColor(r, g, b);
		//	rgb[0] = r/255.0;
		//	rgb[1] = g/255.0;
		//	rgb[2] = b/255.0;
		//	pBRepAccessAsGraphics->Release();
		//	pBRepAccessAsGraphics = NULL ;
		//}

		API_WritePolyLine( nPts, points, size, buffer );
		CATULONG32 pHandle;
		pHandle=piEdge->GetPersistentTag();
		char cHandle[100];
		sprintf(cHandle,"%d",pHandle);
		API_WriteGeometryHandle(cHandle);


		if( size > 0 )
		{
			API_FreeBuffer(buffer);
			size = 0;
		}
	}

	// Retrieves all the body vertices.
	//
	if(false) //这里点不在转换
	{
		CATLISTP(CATCell) vertices;
		pBody->GetAllCells( vertices,0);
		int numberOfVertices = vertices.Size();
		double coord[3];

		for ( j=1 ; j<=numberOfVertices ; j++)
		{
			CATVertex *pVertex = (CATVertex *)vertices[j];
			CATPoint *pPoint = pVertex->GetPoint();
			pPoint->GetCoord(coord[0], coord[1], coord[2]);

			API_WritePointToBuffer( coord, size, buffer );
			API_WritePoint( float(coord[0]), float(coord[1]), float(coord[2]), size, buffer );

			if( size > 0 )
			{
				API_FreeBuffer(buffer);
				size = 0;
			}
		}
	}

	//delete pTessellator;
	pTessellator = NULL;

	return TRUE;
}

//ls ,20170426,获取body显示状态
BOOL CSaveHoops::GetBodyVisiblity(CATBaseUnknown_var pElement)
{
	
	CATIMmiMechanicalFeature_var TheSpeObj = pElement;
	//判断体是否可见
	CATIVisProperties *pBodyVisProps = 0;
	int rc= TheSpeObj->QueryInterface(IID_CATIVisProperties,(void**)&pBodyVisProps) ;			
	if (SUCCEEDED(rc))
	{                
		CATVisPropertiesValues visual;
		rc=pBodyVisProps->GetPropertiesAtt(visual, CATVPShow, CATVPGlobalType);
		if(SUCCEEDED(rc))
		{
			CATShowAttribut showAttrib;
			rc=visual.GetShowAttr(showAttrib);
			if(showAttrib==CATNoShowAttr || showAttrib==CATInvisibleAttr)
			{
				return FALSE;
			}
		}
	}
	CATIMmiMechanicalFeature_var TheSpeObjFather;

	CATBaseUnknown_var pUnk;
	 TheSpeObj->GetMechanicalFather(TheSpeObjFather);
	 pUnk=TheSpeObjFather;
	
	while(pUnk != NULL_var)
	{
		TheSpeObj = pUnk;
		rc= TheSpeObj->QueryInterface(IID_CATIVisProperties,(void**)&pBodyVisProps) ;	
		if (SUCCEEDED(rc))
		{                
			CATVisPropertiesValues visual;
			rc=pBodyVisProps->GetPropertiesAtt(visual, CATVPShow, CATVPGlobalType);
			if(SUCCEEDED(rc))
			{
				CATShowAttribut showAttrib;
				rc=visual.GetShowAttr(showAttrib);
				if(showAttrib==CATNoShowAttr || showAttrib==CATInvisibleAttr)
				{
					return FALSE;
				}
			}
		}
		CATIMmiMechanicalFeature_var FatherTemp;
		TheSpeObj->GetMechanicalFather(FatherTemp);
		pUnk = FatherTemp;
	}
	return TRUE;
}

CATUnicodeString CSaveHoops::GetComponentType(CATIPLMComponent *pComponent)
{
	CATIAdpType* pAdpType=NULL;
	pComponent->GetAdpType(pAdpType);
	CATUnicodeString usType="";
	if(pAdpType!=NULL)
	{
		CATString strClassName;
		strClassName=pAdpType->ClassName();
		pAdpType->GetAlias(usType);
	}
	return usType;
}

HRESULT CSaveHoops::GetMechanicalContainer (CATBaseUnknown * ipOccurrence, CATIMmiPrtContainer ** opiPrtContainer)
{
	HRESULT rc = E_INVALIDARG;

	// Check input parameters
	if (NULL != ipOccurrence && NULL != opiPrtContainer)
	{
		// Initializations
		*opiPrtContainer = NULL;
		rc = S_OK;

		// Get iterator on occurences
		CATIPrdIterator * piIteratorOnOccurrence = NULL;
		CATIPLMRepInstances_var spRepInstOnOccurrence = ipOccurrence;      
		if (NULL_var != spRepInstOnOccurrence)
			rc = spRepInstOnOccurrence -> Iterator (piIteratorOnOccurrence);
		else rc = E_UNEXPECTED;         

		// Get the mechanical container
		CATIMmiPrtContainer * piPrtContainer = NULL;
		if (SUCCEEDED(rc) && NULL != piIteratorOnOccurrence) 
		{
			CATBaseUnknown * piBUonRepInstance = NULL;
			if (SUCCEEDED(piIteratorOnOccurrence -> Next(piBUonRepInstance)) && NULL != piBUonRepInstance && NULL == piPrtContainer)
			{
				// Get the representation reference
				CATIPsiRepresentationReference_var spRepReference;
				CATIPLMNavRepReference * piNavRepReference = NULL;
				CATIPLMNavRepInstance_var spNavRepInstance = piBUonRepInstance;
				if (NULL_var != spNavRepInstance)
				{
					rc = spNavRepInstance -> GetRepReferenceInstanceOf (piNavRepReference);
					if (SUCCEEDED(rc))
					{
						spRepReference = piNavRepReference;
						if (NULL_var == spRepReference) rc = E_UNEXPECTED;
					}
				}
				else  rc = E_UNEXPECTED;

				// Switch the representation to "EditMode"
				if (SUCCEEDED(rc))
				{
					CATIPsiRepresentationLoadMode_var spRepresentationLoadMode = spRepReference;
					if (NULL_var != spRepresentationLoadMode)
						spRepresentationLoadMode -> ChangeLoadingMode (CATIPsiRepresentationLoadMode::EditMode);  
					else  rc = E_UNEXPECTED;
				}

				// Get the mechanical container in the 3DShape stream
				if (SUCCEEDED(rc) && NULL != piNavRepReference)
				{
					CATUnicodeString usMainDataType;
					rc = spRepReference -> GetMainDataType(usMainDataType);
					if (SUCCEEDED(rc) && usMainDataType == "CATPart")
						rc = piNavRepReference -> RetrieveApplicativeContainer ("CATPrtCont", IID_CATIMmiPrtContainer, (void**) opiPrtContainer);
				}
				if (NULL != piNavRepReference)  {piNavRepReference -> Release(); piNavRepReference = NULL;}
			}
		}

		if (NULL != piIteratorOnOccurrence)  {piIteratorOnOccurrence -> Release(); piIteratorOnOccurrence = NULL;}
	}

	return rc;
}


//如果一个body中只有线或者只有点，这个体就是一个geometry，这个下面的内容都放在一个段中；
BOOL CSaveHoops::WriteGeometrySet(CATBody *pBody,CATIMmiUseGeometricalElement_var spFeatureResultGeomElem)
{
	CATLISTP(CATCell) faces;
	pBody->GetAllCells( faces,2);
	int numberOfFaces = faces.Size();
	if (numberOfFaces > 0)  //当模型中存在面的时候就直接返回,用原来的方式进行转换
		return FALSE;

	CATLISTP(CATCell) edges;
	pBody->GetAllCells( edges,1);
	int numberOfEdges = edges.Size();


	CATLISTP(CATCell) vertices;
	pBody->GetAllCells( vertices,0);
	int numberOfVertices = vertices.Size();
	int size;
	char *buffer;

	if(numberOfEdges==0 && numberOfVertices==0) //没有点也没有线，直接返回；
		return FALSE;

	//得到体的名称：
	CString strfatherName;
	CString strPath = CComFun::GetObjName(spFeatureResultGeomElem);
	CATIMmiMechanicalFeature_var TheSpeObj = spFeatureResultGeomElem;
	if(TheSpeObj!=NULL_var)
	{
		CATBaseUnknown_var pUnk;
		CATIMmiMechanicalFeature_var pFather;
		TheSpeObj->GetMechanicalFather(pFather);
		pUnk=pFather;
		while(pUnk != NULL)
		{
			strfatherName = CComFun::GetObjName(pUnk);
			TheSpeObj = pUnk;
			CATIMmiMechanicalFeature_var pFatherTemp;
			TheSpeObj->GetMechanicalFather(pFatherTemp);
			pUnk=pFatherTemp;
			strPath = strfatherName + "/" + strPath;
		}

	}
	if(strPath.IsEmpty())
		strPath="BodyPath=''"; //体的路径

	else
		strPath="BodyPath='"+strPath+"'"; //体的路径
	// 焊点路径
	CATUnicodeString ustrOption;
	char cOption[1000];
	ustrOption.BuildFromWChar(strPath.AllocSysString());
	strcpy(cOption,ustrOption.ConvertToChar());

	CATICGMBodyTessellator * pTessellator = CATCGMCreateBodyTessellator(pBody,CComFun::gfChord);
	if (NULL==pTessellator)
	{				
		return FALSE; //三角化不成功；				
	}
	pTessellator -> Run();

	//转换线

	API_OpenSegment("GeomtrySets"); //在close之前函数不能return；
	int j;
	HRESULT rc;
	if(numberOfEdges>0) //有线的话就不转换点；
	{
		for ( j=1 ; j<=numberOfEdges ; j++)
		{
			size=0;
			CATEdge * piEdge = (CATEdge*) edges[j];

			// 
			// for each edge, retrieve the tessellation results.
			//
			CATLONG32 nPts;
			float *points;
			pTessellator->GetEdge(piEdge, nPts, &points);


			//得到边的几何
			CATEdgeCurve *pGeometry=piEdge->GetCurve();
			CATCurve *pCurve;
			double root[3];
			double dir[3];
			double radius;
			CATMathPoint ioOrigin;
			CATMathDirection ioDirection;
			CATMathPlane axis;

			rc= pGeometry->QueryInterface(IID_CATLine,(void**)&pCurve) ;
			if (SUCCEEDED(rc) )
			{
				if(pCurve->IsAKindOf("CATLine"))//直线
				{
					CATLine *pLine = (CATLine *)pCurve;
					pLine->GetOrigin(ioOrigin);
					pLine->GetDirection(ioDirection);
					ioOrigin.GetCoord(root);
					ioDirection.GetCoord(dir);
					API_WriteLineToBuffer( root, dir, size, buffer );
				}
				pCurve->Release();
				pCurve=NULL;
			}
			else if ( SUCCEEDED(pGeometry->QueryInterface(IID_CATCircle,( void**)&pCurve)) )
			{
				if(pCurve->IsAKindOf("CATCircle"))
				{
					CATCircle *pCircle =(CATCircle *)pCurve;
					radius=pCircle->GetRadius();
					axis = pCircle->GetAxis();
					axis.GetOrigin(ioOrigin);
					axis.GetNormal(ioDirection);
					ioOrigin.GetCoord(root);
					ioDirection.GetCoord(dir);
					API_WriteArcToBuffer( root, dir, radius, size, buffer );

				}
				pCurve->Release();
				pCurve=NULL;		
			}


			//得到线的颜色
			CATCell_var pCell ( piEdge );
			//CATIMmiUseBRepAccess_var spBRepAccess ( CATBRepDecode(pCell, DecodeCellInGeomElt) );
			CATIMmiUseBRepAccess_var spBRepAccess; 
			CATIMmiUseBRepDecodeServices_var spBRepDecodeServices;
			CATMmiUseServicesFactory::CreateBRepDecodeServices(spBRepDecodeServices);
			spBRepDecodeServices->DecodeCellInGeomElt(spBRepAccess,pCell,spFeatureResultGeomElem);
			CATIVisProperties *pBRepAccessAsGraphics = 0;
			rc= spBRepAccess->QueryInterface(IID_CATIVisProperties,
				(void**)&pBRepAccessAsGraphics) ;

			unsigned int r,g,b;
			double rgb[3];
			if ( SUCCEEDED(rc) )
			{                
				CATVisPropertiesValues color;
				pBRepAccessAsGraphics->GetPropertiesAtt(color, CATVPColor, CATVPMesh);
				color.GetColor(r, g, b);
				rgb[0] = r/255.0;
				rgb[1] = g/255.0;
				rgb[2] = b/255.0;
				pBRepAccessAsGraphics->Release();
				pBRepAccessAsGraphics = NULL ;
			}

			API_WritePolyLine( nPts, points, size, buffer );
			CATULONG32 pHandle;
			pHandle=piEdge->GetPersistentTag();
			char cHandle[100];
			sprintf(cHandle,"%d",pHandle);
			API_WriteGeometryHandle(cHandle);
			API_WriteGeometryOption(cOption);



			if( size > 0 )
			{
				API_FreeBuffer(buffer);
				//				delete [] buffer;
				//				buffer = NULL;
				size = 0;
				buffer=NULL;
			}
		}
	}
	else
	{

		//转换点
		double coord[3];

		for ( j=1 ; j<=numberOfVertices ; j++)
		{
			CATVertex *pVertex = (CATVertex *)vertices[j];
			CATPoint *pPoint = pVertex->GetPoint();
			pPoint->GetCoord(coord[0], coord[1], coord[2]);

			API_WritePointToBuffer( coord, size, buffer );
			API_WritePoint( float(coord[0]), float(coord[1]), float(coord[2]), size, buffer );
			API_WriteGeometryOption(cOption);

			if( size > 0 )
			{
				API_FreeBuffer(buffer);
				size = 0;
			}
		}
	}

	API_CloseSegment();




	return TRUE;
}

void CSaveHoops::SetWeldingPointUserOption(CATBody *pBody,CATIMmiUseGeometricalElement_var spFeatureResultGeomElem)
{
	CATLISTP(CATCell) faces;
	pBody->GetAllCells( faces,2);
	int numberOfFaces = faces.Size();
	if (numberOfFaces > 0) return;

	CATLISTP(CATCell) edges;
	pBody->GetAllCells( edges,1);
	int numberOfEdges = edges.Size();
	if (numberOfEdges > 0) return;

	CATLISTP(CATCell) vertices;
	pBody->GetAllCells( vertices,0);
	int numberOfVertices = vertices.Size();
	if (numberOfVertices > 0)
	{
		CString strfatherName;
		CString strPath = CComFun::GetObjName(spFeatureResultGeomElem);
		//CATISpecObject_var TheSpeObj = spFeatureResultGeomElem;
		//CATBaseUnknown_var pUnk = TheSpeObj->GetFather();
		//while(pUnk != NULL)
		//{
		//	strfatherName = GetBodyName(pUnk);
		//	TheSpeObj = pUnk;
		//	pUnk = TheSpeObj->GetFather();
		//	strPath = strfatherName + "/" + strPath;
		//}
		CATIMmiMechanicalFeature_var TheSpeObj = spFeatureResultGeomElem;
		if(TheSpeObj!=NULL_var)
		{
			CATBaseUnknown_var pUnk;
			CATIMmiMechanicalFeature_var pFather;
			TheSpeObj->GetMechanicalFather(pFather);
			pUnk=pFather;
			while(pUnk != NULL)
			{
				strfatherName = CComFun::GetObjName(pUnk);
				TheSpeObj = pUnk;
				CATIMmiMechanicalFeature_var pFatherTemp;
				TheSpeObj->GetMechanicalFather(pFatherTemp);
				pUnk=pFatherTemp;
				strPath = strfatherName + "/" + strPath;
			}

		}

		if(strPath.IsEmpty())
			return ;
		strPath="PointPath='"+strPath+"'"; //加上一个类型
		// 焊点路径
		CATUnicodeString ustrOption;
		char cOption[1000];
		ustrOption.BuildFromWChar(strPath.AllocSysString());
		strcpy(cOption,ustrOption.ConvertToChar());
		API_SetUserOptions(cOption);
	}
}

void CSaveHoops::SaveStep(CATIPLMComponent *pComponent)
{
	if(pComponent==NULL)
		return ;
	HRESULT rc;
	CATDieImportExportServices * ServicesInstance = CATDieImportExportServices::GetInstance() ;
	if ( NULL != ServicesInstance )  //输出dxf
	{
		CATUnicodeString OutputFilePath;
		OutputFilePath.BuildFromBSTR(CComFun::gstrOutputPath.AllocSysString());
		CATUnicodeString OutputFileExtension=".step";
		CATUnicodeString OutputUsage="STEP";
		rc = ServicesInstance->ExportPLMObjectToExternalFile ( pComponent ,
			OutputFilePath ,
			OutputFileExtension ,
			OutputUsage ) ;
		if(SUCCEEDED(rc))
		{
			//输出成功
		}
	}

	CATDieImportExportServices::DeleteInstance();
	if ( FAILED(rc) )
	{
		CATError * pErrorMessage = CATError::CATGetLastError(rc) ;
		if (pErrorMessage)
		{
			pErrorMessage -> Release () ;
			pErrorMessage = NULL ;
		}
	}
}
int  CSaveHoops::GetDocParameter(CATIPLMComponent *pComponent,int &iPropSetsCount,CString *&strNames,CString *&strDisplayName,CStringList *&lstTitle,CStringList *&lstDisplayTitle,CStringList *&lstValue)
{
	//CATUnicodeString fileName = pDoc->StorageName();

	//char cFileName[255];
	////char xmlFile[255];
	//strcpy( cFileName,fileName );

	//CString strFileName;
	//strFileName=cFileName;
	//CString strFileNameShort;
 //   strFileNameShort=PathFindFileName(strFileName);
	//CString strExt=PathFindExtension(strFileName);

	//strFileNameShort=strFileNameShort.Left(strFileNameShort.GetLength()-strExt.GetLength());
 //   //strFileNameShort+="\\";
	//iPropSetsCount=0;
	//CATInit *pDocAsInit = NULL ;
	//HRESULT rc;
	//rc = pDoc->QueryInterface(IID_CATInit, (void**)&pDocAsInit);
	//if ( FAILED(rc) )
	//{		
	//	return 1 ;
	//}

	//CATIPrtContainer *pSpecContainer = NULL ;
	//pSpecContainer = (CATIPrtContainer*)pDocAsInit->GetRootContainer("CATIPrtContainer");
	//if ( NULL == pSpecContainer )
	//{
	//  return 1 ;
	//}

	//CATIContainer* piRootContainer = NULL;	
	//if(pDocAsInit)
	//{
	//	piRootContainer = (CATIContainer*) pDocAsInit -> GetRootContainer("CATIContainer");
	//}
	//
	//CATICkeParmFactory* piFact = NULL;
	//rc = piRootContainer->QueryInterface(IID_CATICkeParmFactory, (void**) &piFact);
	//pDocAsInit->Release();
	//pDocAsInit = NULL ;

	//CATIPrtPart_var spPart = pSpecContainer->GetPart() ;
	//
	//if ( NULL_var == spPart )
	//{	
	//	return 1 ;
	//}
	////_piFact=piFact;
	//CATIParmPublisher_var spPublisher = spPart;
	//if(spPublisher == NULL_var )
	//	return 1;
	//if( spPublisher != NULL_var)
	//{
	//	//ListParametersUnderPublisher( root );
	//	
	//	CATLISTV(CATBaseUnknown_var) list;
	//	CATIVisitor_var aStandardVisitor = piFact->CreateStandardVisitor(IID_CATICkeParm, &list);
	//	spPublisher->VisitChildren(aStandardVisitor, 1);
 //       int size = list.Size();
	//	if(size>0)
	//	{
	//		iPropSetsCount=1;
	//		strNames=new CString();
	//		strNames[0]=_T("Parameters");
	//		strDisplayName=new CString[iPropSetsCount];
	//		strDisplayName[0]=_T("参数表");
	//		lstTitle=new CStringList[iPropSetsCount];
	//		lstDisplayTitle=new CStringList[iPropSetsCount];
	//		lstValue=new CStringList[iPropSetsCount];
	//	}

	//	int i = 0;
	//	for(i=1; i <=size; i++)
	//	{
	//		CATICkeParm_var pICkeParm = list[i];
	//		CString strName;
	//		strName=pICkeParm->Name().ConvertToChar();
	//		if(0==strName.Find(strFileNameShort))
	//		{ 
	//			int len=strFileNameShort.GetLength();
	//			strName=strName.Right(strName.GetLength()-len-1);
	//		}
	//		POSITION pos=lstTitle[0].Find(strName);
	//		if(pos)
	//		{
	//			continue;
	//		}
	//		CString strValue;
	//		strValue=pICkeParm->Value()->AsString().ConvertToChar();

	//		lstTitle[0].AddTail(strName);
	//		lstDisplayTitle[0].AddTail(strName);
	//		lstValue[0].AddTail(strValue);		
	//	}
	//	
	//}
	//else
	//	rc = 3;

	//pSpecContainer->Release();
	//pSpecContainer = NULL;
	return 1;

}


BOOL CSaveHoops::GetDocAttribute(CATIPLMComponent *pComponent,CStringList &strlistName,CStringList &strlistDisplay,CStringList &strlistValue)
{
	HRESULT rc;
	if(pComponent==NULL)
		return FALSE;
	CATICkeObject_var pCheckObj=pComponent;
	if(pCheckObj==NULL_var)
		return FALSE;
	CATListValCATAttributeInfos ListOfAttributeInfos;
	rc = CATCkePLMNavPublicServices::ListAttributesFromObject(CATCkePLMTypeAttrServices::All,
		pCheckObj,
		ListOfAttributeInfos,
		FALSE);
	if(ListOfAttributeInfos.Size()<=0)
		return FALSE;

	for(int i=1;i<=ListOfAttributeInfos.Size();i++)
	{
		CATAttributeInfos AttrInfo =  ListOfAttributeInfos[i];

		// A- Retrieve attribute name with a Call to CATAttributeInfos::Name
		CATUnicodeString attrName;
		attrName = AttrInfo.Name();
		CATUnicodeString stringValue;
		CATCkeObjectAttrReadServices::GetValueAsString(pCheckObj,attrName,stringValue);
		strlistName.AddTail(attrName.ConvertToChar());
		strlistDisplay.AddTail(attrName.ConvertToChar());
		strlistValue.AddTail(stringValue.ConvertToChar());
	}

	ListOfAttributeInfos.RemoveAll();
	return TRUE;
	//CATListValCATAttributeInfos attrInfoList;
	//rc = piAttrDesc->List(&attrInfoList);
	//if (FAILED(rc)) 
	//{	
	//}
	//else
	//{
	//	int attrCount = attrInfoList.Size();
	//	for (int i = 1; i <= attrCount; i++) {
	//		CATAttributeInfos attrInfo = attrInfoList[i];
	//		const CATUnicodeString& propertyName = attrInfo.Name();
	//		const CATUnicodeString& valueType = attrInfo.Type()->Name();
	//		CATIValue *pValue /*= piInstance->GetValue(propertyName)*/;
	//		CATUnicodeString valueString;
	//		if (pValue == NULL) {
	//			valueString = "";
	//		} else {
	//			rc = pValue->AsString(valueString);
	//			if (FAILED(rc))
	//				valueString = "";
	//			pValue->Release();
	//			pValue = NULL;
	//		}			
	//		CString strNameTemp;
	//		strNameTemp=propertyName.ConvertToChar();
	//		if(strNameTemp.CompareNoCase(_T("材料"))==0)
	//		{
	//			strlistName.AddTail(_T("Material"));
	//		}
	//		else
	//		{
	//			strlistName.AddTail(propertyName.ConvertToChar());
	//		}
	//		strlistValue.AddTail(valueString.ConvertToChar());
	//	}
	//}
	//piAttrDesc->Release();
	//piAttrDesc = NULL;

	return TRUE;
}

CString CSaveHoops::WrtitAllAttributeInXmlString(int iPropSetsCount,CString *strNames,CString *strDisplayName,CStringList *lstTitle,CStringList *lstDisplayTitle,CStringList *lstValue)
{
	if(iPropSetsCount<=0)
		return _T("");

	CComPtr<IXMLDOMDocument> pXmlDoc;
	pXmlDoc=CIvFile::CreateXmlDoc();
	CComPtr<IXMLDOMElement> pXmlRoot;
	pXmlRoot=CIvFile::XmlAddChild(pXmlDoc,NULL,_T("root"));
	CComPtr<IXMLDOMElement> pXmlPropSets;
	pXmlPropSets=CIvFile::XmlAddChild(pXmlDoc,pXmlRoot,_T("PropSets"));

	POSITION pos1,pos2,pos3;
	for(int i=0;i<iPropSetsCount;i++)
	{
		CComPtr<IXMLDOMElement> pXmlPropSet;
		pXmlPropSet=CIvFile::XmlAddChild(pXmlDoc,pXmlPropSets,_T("PropSet"));



		CIvFile::XmlSetAttribute(pXmlPropSet,_T("Name"),strNames[i]);
		CIvFile::XmlSetAttribute(pXmlPropSet,_T("DisplayName"),strDisplayName[i]);

		pos1=lstTitle[i].GetHeadPosition();
		pos2=lstDisplayTitle[i].GetHeadPosition();
		pos3=lstValue[i].GetHeadPosition();

		while(pos1&& pos2 && pos3)
		{
			CString strTemp1,strTemp2,strTemp3;
			strTemp1=lstTitle[i].GetNext(pos1);
			strTemp2=lstDisplayTitle[i].GetNext(pos2);
			strTemp3=lstValue[i].GetNext(pos3);

			CComPtr<IXMLDOMElement> pXmlProp;
			pXmlProp=CIvFile::XmlAddChild(pXmlDoc,pXmlPropSet,_T("Prop"));
			CIvFile::XmlSetAttribute(pXmlProp,_T("Name"),strTemp1);
			CIvFile::XmlSetAttribute(pXmlProp,_T("DisplayName"),strTemp2);
			CIvFile::XmlSetAttribute(pXmlProp,_T("Value"),strTemp3);
		}

	}

	BSTR bstXMLString;
	pXmlDoc->get_xml(&bstXMLString);
	CString strReturn;
	strReturn=bstXMLString;
	return strReturn;

}
BOOL  CSaveHoops::GetDocAttribute(CATIPLMComponent *pComponent,CString& strPropName,CString& strTitle,CString& strValue)
{
	strPropName=_T("");
	strTitle=_T("");
	strValue=_T("");

	CStringList lstName;
	CStringList lstValue;
	CStringList lstDisplay;
	GetDocAttribute(pComponent,lstName,lstDisplay,lstValue);
	POSITION pos1,pos2,pos3;
	pos1=lstName.GetHeadPosition();
	pos2=lstDisplay.GetHeadPosition();
	pos3=lstValue.GetHeadPosition();
	while(pos1&&pos2&&pos3)
	{
		CString nameTemp,displyTemp,valueTemp;
		nameTemp=lstName.GetNext(pos1);
		displyTemp=lstDisplay.GetNext(pos2);
		valueTemp=lstValue.GetNext(pos3);

		strPropName+=nameTemp+_T("#,#");
		strTitle+=displyTemp+_T("#,#");
		strValue+=valueTemp+_T("#,#");
	}


	return TRUE;
}
void CSaveHoops::SavePartFromGraph(CATIPLMComponent *pComponent)
{
	if(pComponent==NULL)
		return ;

	if(CComFun::gbOutputStep) //输出step文件
	{
		CString strLocalFileName;
		strLocalFileName=CComFun::GetLocalPath(pComponent);
		CComFun::ExportStep(pComponent,strLocalFileName);
	}

	CATIMmiPrtContainer *piPrtContainer=NULL;
	GetMechanicalContainer(pComponent,&piPrtContainer);
	HRESULT rc;
	if(piPrtContainer==NULL)
		return;
	CATIMmiMechanicalFeature_var spMechFeatOnPart ;
	rc=piPrtContainer->GetMechanicalPart(spMechFeatOnPart); //得到part feature
	if(spMechFeatOnPart==NULL_var)
		return ;

	CATI3DGeoVisu_var pGeoVis;
	pGeoVis=spMechFeatOnPart;
	if(pGeoVis==NULL_var)
		return ;
	CATRep * pRep = pGeoVis->GiveRep();

	if(pRep==NULL)
	{
		return ;
	}
	CString strIntevueFileName=CComFun::ToIntevueFile(pComponent);
	CATUnicodeString usIntevuFileName;
	usIntevuFileName.BuildFromBSTR(strIntevueFileName.AllocSysString());
	char cIntevueFile[1000];
	strcpy(cIntevueFile,usIntevuFileName.ConvertToChar());
	API_InitConverter(cIntevueFile);
		ConvertRep(pRep);
	API_TerminateConverter();

}

void CSaveHoops::ConvertRep(CATRep *pRep)
{
	if(pRep==NULL)
		return ;


	CString strName;
	strName=CComFun::GetObjName(pRep);
	CString strIntevueFileName;
	
	//AfxMessageBox(strName);


	if(pRep->IsAKindOf(CATSurfacicRep::ClassName())) //面模型
	{
	
		CATSurfacicRep *p3dFaceRep = (CATSurfacicRep*)pRep;
		int faceNum = p3dFaceRep->GeomNumberOfFaces();

		for (int i = 0; i < faceNum; i++)
		{
			CAT3DFaceGP *pFaceGP = p3dFaceRep->GeomFace(i);
			CATGraphicAttributeSet *faceAttrSet= p3dFaceRep->GeomFaceAttribut(i);

			//获得颜色
			int r = 0, g = 0, b = 0,a=0;
			faceAttrSet->GetColorRGBA(&r, &g, &b, &a);
			double *rgb = new double[3];
			rgb[0] = r / 255.0; 
			rgb[1] = g / 255.0;
			rgb[2] = b / 255.0;

			//face_list长度
			int flist_length = 0;

			////获得点的数组和个数
			//float * vertices = pFaceGP->GetVertices();
			//int verticesNum = pFaceGP->GetNumberOfVertices();
			//
			////得到法矢向量和个数
			//float *normals = pFaceGP->GetNormals();
			//int  normalsNum = pFaceGP->GetNumberOfNormals();

			//面顶点坐标数组
			int 	oAllocate = 0;
			float* oVertices = NULL;
			int 	oVerticesArraySize;

			//面顶点法失
			float* oNormals = NULL;
			int oNormalsArraySize = NULL;

			//独立三角
			int* oTriangleIndices = NULL;
			int 	oNbTriangle;
			//三角形带
			int* oTriangleStripIndices = NULL;
			int	oNbTriangleStrip;
			int* oNbVertexPerTriangleStrip = NULL;//每个三角形带的顶点个数
			//扇形三角形
			int* oTriangleFanIndices = NULL;
			int 	oNbTriangleFan;
			int* oNbVertexPerTriangleFan = NULL;

			pFaceGP->Get(&oAllocate, &oVertices, &oVerticesArraySize, &oNormals, &oNormalsArraySize, &oTriangleIndices, &oNbTriangle, &oTriangleStripIndices, &oNbTriangleStrip, &oNbVertexPerTriangleStrip, &oTriangleFanIndices, &oNbTriangleFan, &oNbVertexPerTriangleFan);

			//Normals长度与Vertices长度不一致时
			float* newNormals=new float[oVerticesArraySize];
			int newNormalsArraySize=0;
			if(oVerticesArraySize!=oNormalsArraySize)
			{
				for (int i=0;i<oVerticesArraySize;i++)
				{
					int j=i%3;
					newNormals[i]=oNormals[j];
				}
			}
			else
			{
				for (int i=0;i<oVerticesArraySize;i++)
				{
					newNormals[i]=oNormals[i];
				}
			}
			newNormalsArraySize=oVerticesArraySize;
			
			//三角形个数
			//int triangleNum = oNbTriangle + oNbTriangleStrip + oNbTriangleFan;

			//计算face_list长度
			//独立三角形
			flist_length += 4 * oNbTriangle;

			//三角形带
			for (int j = 0; j < oNbTriangleStrip; j++)
			{
				flist_length += (oNbVertexPerTriangleStrip[j] -2)*4;
			}

			//扇形三角形
			int fansVe=0;
			for (int k = 0; k < oNbTriangleFan; k++)
			{
				flist_length += (oNbVertexPerTriangleFan[k] -2)*4;
				fansVe+=oNbVertexPerTriangleFan[k];
			}

			//构造face_list
			int *face_list = new int[flist_length];
			//s表示第s个独立三角形
			for (int s = 0; s < oNbTriangle; s++)
			{
				int t = s * 4;
				int d = s * 3;
				face_list[t] = 3;
				face_list[t + 1] = oTriangleIndices[d]/3;
				face_list[t + 2] = oTriangleIndices[d + 1]/3;
				face_list[t + 3] = oTriangleIndices[d + 2]/3;
			}
			//三角形带
			int listIndex = oNbTriangle * 4;
			int begIndex=0,verIndex;
			for (int index = 0; index < oNbTriangleStrip; index++)
			{
				//第index个三角形带的第j个顶点
				
				if(index!=0)
				begIndex += oNbVertexPerTriangleStrip[index-1];
				verIndex=begIndex;
				for (int j=0; j <oNbVertexPerTriangleStrip[index]-2; j++)
				{
					face_list[listIndex] = 3;// oNbVertexPerTriangleStrip[index];
					if (j%2==0)
					{
						face_list[listIndex+1] = oTriangleStripIndices[verIndex] / 3;
						face_list[listIndex+2] = oTriangleStripIndices[verIndex+1] / 3;
						face_list[listIndex+3] = oTriangleStripIndices[verIndex+2] / 3;
					}
					else
					{
						face_list[listIndex+1] = oTriangleStripIndices[verIndex+1] / 3;
						face_list[listIndex + 2] = oTriangleStripIndices[verIndex] / 3;
						face_list[listIndex + 3] = oTriangleStripIndices[verIndex + 2] / 3;
					}
					listIndex += 4;
					verIndex++;
				}
			}
			//扇形三角形
			int centerFan;
			for (int index = 0; index < oNbTriangleFan; index++)
			{
				if(index!=0)
				{
				    centerFan +=oNbVertexPerTriangleFan[index-1];
					verIndex=centerFan;
				}
				else
				{
					verIndex=0;centerFan=0;
				}
				//第index个扇形三角形的第j个顶点
				for (int j = 0; j < oNbVertexPerTriangleFan[index]-2; j++)
				{
					face_list[listIndex] = 3;// oNbVertexPerTriangleFan[index];
					face_list[listIndex+1] = oTriangleFanIndices[centerFan] / 3;
					face_list[listIndex+2] = oTriangleFanIndices[verIndex+1] / 3;
					face_list[listIndex+3] = oTriangleFanIndices[verIndex+2] / 3;
					listIndex += 4;
					verIndex++;
				}
			}
			
			float box[6];
			box[0] = 10;
			box[1] = 10;
			box[2] = 10;
			box[3] = -10;
			box[4] = -10;
			box[5] = -10;

			vector<int> fansVec(fansVe,0);
			for (int i=0;i<fansVe;i++)
			{
				fansVec[i]=oTriangleFanIndices[i];
			}
			vector<int> faceVec(flist_length,0);
			for (int i=0;i<flist_length;i++)
			{
				faceVec[i]=face_list[i];
			}

			API_WriteShell(oVerticesArraySize / 3, oVertices, newNormals, flist_length, face_list, box, 0, NULL, rgb);
		}

	}
	else if(pRep->IsAKindOf(CAT3DGeomRep::ClassName()))
	{
		//AfxMessageBox(CString(CAT3DGeomRep::ClassName()));
	}
	else if(pRep->IsAKindOf(CAT3DBagRep::ClassName()))
	{
		//AfxMessageBox(CString(CAT3DBagRep::ClassName()));
		CAT3DBagRep *p3dBagRep=(CAT3DBagRep*)pRep;
		//CAT3DBagRep_var p3dBagRep=pRep;
		pRep->GetChildren();
		list<CATRep> * pChildren=p3dBagRep->GetChildren();
		if(pChildren)
		{
			int iCount;
			iCount=pChildren->length();
			CString strTemp;
			strTemp.Format(_T("child %d"),iCount);
			
			API_OpenSegment("");
			for(int i=0;i<pChildren->length();i++)
			{
				CATRep *pChild=(*pChildren)[i];
				//if(pChild!=pRep) //避免循环
				ConvertRep(pChild/*,HasProcessed*/);
			}
			API_CloseSegment();
		}

	}
	
	else if(pRep->IsAKindOf(CAT3DRep::ClassName()))
	{
		CAT3DRep *p3dRep=(CAT3DRep *)pRep;
		//AfxMessageBox(CString(CAT3DRep::ClassName()));
	}
}