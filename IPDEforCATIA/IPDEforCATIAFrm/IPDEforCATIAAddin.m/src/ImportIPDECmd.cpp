//===================================================================
// COPYRIGHT TY 2019/01/03
//===================================================================
// ImportIPDECmd.cpp
// Header definition of class ImportIPDECmd
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2019/01/03 Creation: Code generated by the 3DS wizard
//===================================================================

#include "ImportIPDECmd.h"
#include "CComFun.h"

#include "CATIPrdObject.h"
#include "CATFrmEditor.h"
#include "CATPathElement.h"
#include "CATIPLMProducts.h"
#include "CATIPLMComponent.h"
#include "CATPLMCoreType.h"
#include "CATIAdpType.h"
#include "CATCreateExternalObject.h" 
#include "CATListPtrCATIPLMComponent.h"
#include "CATPLMComponentInterfacesServices.h"
#include "CATDlgFile.h"
#include "CATDlgWindow.h"
#include "CATApplicationFrame.h"
#include "CATIMmiUseGeometricalElement.h"
#include "CATIPLMComponent.h"
#include "CATBaseUnknown.h"
#include "CATIPLMProducts.h"
#include "CATIPLMComponent.h"
#include "CATDlgLabel.h"
#include "CATDlgGridConstraints.h"
#include "CATDieImportExportServices.h"
#include  "CAADLCBatchEventWatcher.h"			//To create a batch event watcher
//  CAAPLMClientAdapter.edu  Framework
#include "CAAAdpCreateCloseSession.h"			//To create a session

// PLMBatchDataAccessInterfaces Framework
#include "CATPLMBatch.h"						//To create the batch instance
#include "CATPLMBatchXMLToolBox.h"				//::ReadPathQueryMappingFile API call

// CATPLMIdentificationAccess Framework
#include "CATIAdpPLMIdentificator.h"			//CATIAdpPLMIdentificator ptr creation
#include "CATListPtrCATIAdpPLMIdentificator.h"	//CATListPtrCATIAdpPLMIdentificator var creation
#include "CATAdpQueryServices.h"				//::::GetIdentificationSet API call
#include "CATAdpIdentificationSet.h"			//CATAdpIdentificationSet var creation

// BatchInfrastructure Framework
#include  "CATBatClientMonitorCAA.h"			//::GetTheClientMonitorCAA() API call

// PLMSessionInterfaces Frameworks
#include "PLMPSISessionHelpers.h"    

// System
#include "CATError.h"							//Error management. ::CATGetLastError API call
#include "CATUnicodeString.h"
#include "CATListOfCATUnicodeString.h"

#include "CATSysSettingRepository.h"
#include "CATDataType.h"

// Standard C++ library
#include <iostream.h>
#include <fstream.h>	//File Handling
#include "CATString.h"
#include "CataModule.h"

#include <Windows.h>
#include <WinBase.h>
#include <Tlhelp32.h>

BOOL LibToCatalog(char* cFileName,char* cOutPath);
void ThrowLastErrorMessage(HRESULT RC);
HRESULT RetrieveIdentifierSet(CATIAdpPLMIdentificator * iIdentifier);
HRESULT LaunchFBDIBatch(CATUnicodeString &iXmlPath);
void ImportCatalog(CString selectPath);



#ifndef _WINDOWS_
#include <afxwin.h>
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#else
#undef  _WINDOWS_
#include <afxwin.h>
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#define  _WINDOWS_
#endif

CATCreateClass(ImportIPDECmd);
//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------



UINT GetProcessIdByName(LPCTSTR pszExeFile)

{

	UINT nProcessID = 0;

	PROCESSENTRY32 pe = {sizeof(PROCESSENTRY32)};



	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, 0);

	if (hSnapshot != INVALID_HANDLE_VALUE)

	{

		if (Process32First(hSnapshot, &pe))

		{

			while (Process32Next(hSnapshot, &pe))

			{

				if (lstrcmpi(pszExeFile, pe.szExeFile) == 0)

				{

					nProcessID = pe.th32ProcessID;

					break;

				}

			}

		}

		CloseHandle(hSnapshot);

	}

	return nProcessID;

}




HRESULT LaunchFBDIBatch(CATUnicodeString &iXmlPath)
{
	HRESULT hr = S_OK ;
	//Retrieve  the  ClientMonitor,  main  interface  to  start  and  monitor  batches  
	CATBatClientMonitorCAA*    cliMonitor  =  CATBatClientMonitorCAA::GetTheClientMonitorCAA() ;  
	if  (NULL == cliMonitor)       
		return  E_FAIL ;  

	//We  intialize  the  abitlity  to  monitor  V5  batches  
	hr  =  cliMonitor->InitializeV5Monitoring() ;
	if(FAILED(hr))
		return hr ;
	//We  need  a  specific  object  to  register  callbacks  on  batch  events.  
	//Here  we  are  interested  in  CATBatchEndNotif  only  
	int  cond_for_exit  =  0 ;    
	CAADLCBatchEventWatcher  evt(&cond_for_exit) ;               
	char  uuid[SIZE_T_ID] ;  
	hr  =  cliMonitor->StartV5Batch(iXmlPath,  uuid) ;  

	if  (FAILED(hr))
		return  hr ; 
	//  We  tell  the  CAADLCBatchEventWatcher  which  CATBatchEndNotif  it  must  expect.  
	evt.SetUUID(uuid) ;  
	//We  explicitly  wait  for  the  end  of  the  batch,  when  cond_for_exit==1  the  loop  exits  
	//It  is  up  to  CAADLCBatchEventWatcher  to  set  this  flag  to  1  when  the  right  CATBatchEnd 
	//has  been  received.  
	hr  =  cliMonitor->WaitOnMessage(cond_for_exit) ; 

	if  (FAILED(hr)) 
		return  hr ;  
	int  rc  = 0 ;
	rc = evt.GetRC() ;  //  you  can  also  direclty  call  cliMonitor->GetBatchRC(uuid,  rc);  

	if(0!=rc) 
		hr = E_FAIL ;

	return hr ;
}

HRESULT RetrieveIdentifierSet(CATIAdpPLMIdentificator * iIdentifier)
{
	HRESULT hr = S_OK;
	//	Retrieve the IdentificationSet of this object, thanks to its Identifier
	CATAdpIdentificationSet oIdentifyingSet;
	hr = CATAdpQueryServices::GetIdentificationSet(iIdentifier,oIdentifyingSet);
	if (S_OK == hr)
	{
		int current=0;
		CATString AttributeName;
		CATUnicodeString AttrValue;
		CATString PLMExtID("PLM_ExternalID");
		//	Display PLM_ExternalID value of the current result
		while (S_OK == (oIdentifyingSet.NextAttribute(current,AttributeName,AttrValue)))
		{
			if (PLMExtID == AttributeName)
			{
				cout << "Attribute Name : "<< AttributeName.getUnicodeString() << endl;	
				cout << "Attribute Value: "<< AttrValue.ConvertToChar() << endl << endl;	
				break;
			}
		}

	} 
	return hr;
}

void ThrowLastErrorMessage(HRESULT RC)
{
	CATUnicodeString ErrorMessageKey ("") ;
	CATError * pError = CATError::CATGetLastError(RC) ;
	if ( NULL != pError )
	{        
		ErrorMessageKey = pError->GetNLSMessage() ;		
		cout << "   Complete Error message key is : " <<  ErrorMessageKey.ConvertToChar() << endl ;
		int IdErr = pError->GetId() ;
		cout << "   Error ID : " << IdErr << endl  ;
		cout << endl;
		pError->Release() ;
		pError = NULL ;
	}

}

const char* CString2Char(CString str)
{
	// 先得到要转换为字符的长度
	const size_t strsize=(str.GetLength()+1)*2; // 宽字符的长度;
	char * pstr= new char[strsize]; //分配空间;
	size_t sz=0;
	wcstombs_s(&sz,pstr,strsize,str,_TRUNCATE);
	return pstr;

}

ImportIPDECmd::ImportIPDECmd() :
CATCommand (NULL, "ImportIPDECmd")
{
RequestStatusChange (CATCommandMsgRequestSharedMode);

//CATBaseUnknown *pInput;
//pInput=CComFun::ImportStepFile(_T("C:\\Users\\Ymc\\Desktop\\catia\\IPDE_20181024Send.catalog.catalog"));
//CATIPLMComponent_var spComp;
//spComp=pInput;
//
//CString strLocalFileName="C:\\Users\\Ymc\\Desktop\\catia\\11";
//CComFun::ExportStep(spComp,strLocalFileName);

CATApplicationFrame * pFrame = CATApplicationFrame::GetFrame();
if(pFrame)
{
	CATDlgWindow *pParent;
	pParent=pFrame->GetMainWindow();

	_dlgFile=new CATDlgFile(pParent,"选择文件夹",CATDlgFolderChooser);
	CATUnicodeString usPath;
	usPath.BuildFromBSTR(CComFun::gstrOutputPath.AllocSysString());
	_dlgFile->SetDirectory(usPath);
	_dlgFile->SetVisibility(CATDlgShow);
	//当点击OK的时候就开始转换，否则就不转换了
	AddAnalyseNotificationCB(_dlgFile, 
		_dlgFile->GetDiaOKNotification(), 
		(CATCommandMethod)&ImportIPDECmd::OpenOK, 
		NULL);
}
//LibToCatalog("E:\\projects10\\IPDEforCATIA\\InputData\\IPDE_20181024Send","E:\\projects10\\IPDEforCATIA\\InputData\\IPDE_20181024Send");
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
ImportIPDECmd::~ImportIPDECmd()
{
}


//  Overload this method: when your command gains focus
//
// Activates a command.
//   iFromClient :The command that requests to activate the current one.
//   iEvtDat :The notification sent.
// ----------------------------------------------------
CATStatusChangeRC ImportIPDECmd::Activate( CATCommand * iFromClient, CATNotification * iEvtDat)
{
return (CATStatusChangeRCCompleted);
}

//  Overload this method: when your command loses focus
//
// Deactivates a command.
//   iFromClient :The command that requests to activate the current one.
//   iEvtDat :The notification sent.
// ----------------------------------------------------
CATStatusChangeRC ImportIPDECmd::Desactivate( CATCommand * iFromClient, CATNotification * iEvtDat)
{
return (CATStatusChangeRCCompleted);
}

//  Overload this method: when your command is canceled
//
// Cancel a command.
//   iFromClient :The command that requests to activate the current one.
//   iEvtDat :The notification sent.
// ----------------------------------------------------
CATStatusChangeRC ImportIPDECmd::Cancel( CATCommand * iFromClient, CATNotification * iEvtDat)
{
RequestDelayedDestruction();
return (CATStatusChangeRCCompleted);
}

typedef struct STARTUPOINFOEXA {
	STARTUPINFO                 StartupInfo;
	PPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
};


void ImportIPDECmd::OpenOK(CATCommand           * iSendingCommand, 
	CATNotification      * iSentNotification, 
	CATCommandClientData   iUsefulData)
{
	CATUnicodeString usPath;
	_dlgFile->GetDirectory(usPath);	
	_dlgFile->RequestDelayedDestruction(); //删除这个对话框

	CString strSelectPath;
	strSelectPath=usPath.ConvertToChar();
	if(PathFileExists(strSelectPath)==TRUE)
	{
		CString exe="C:\\Program Files\\Dassault Systemes\\B19\\win_b64\\code\\DirToCatalog.exe";
		//CString work="C:\\Program Files\\Dassault Systemes\\B19\\win_b64\\code\\bin";
		CString cmd="\""+strSelectPath+"\""+" "+"\""+strSelectPath+"\"";
	   // CString cmd="-run \"CNEXT.exe\" -env CATIA.V5R19.B19 -direnv \"C:\\ProgramData\\DassaultSystemes\\CATEnv\" -nowindow";
		//CString bat="E:\\projects10\\IPDEforCATIA\\InputData\\para.bat";
		//"C:\Program Files\Dassault Systemes\B19\win_b64\code\bin\CATSTART.exe"  -run "C:\Program Files\Dassault Systemes\B19\win_b64\code\bin\DirToCatalog.exe" -env CATIA.V5R19.B19 -direnv "C:\ProgramData\DassaultSystemes\CATEnv" -nowindow 
		//"C:\Program Files\Dassault Systemes\B19\win_b64\code\bin\DirToCatalog.exe"  -run "CNEXT.exe" -env CATIA.V5R19.B19 -direnv "C:\ProgramData\DassaultSystemes\CATEnv" -nowindow 
		//"C:\Program Files\Dassault Systemes\B19\win_b64\code\bin\DirToCatalog.exe" -e "C:\Program Files\Dassault Systemes\B19\win_b64\code\bin\setcatenv.exe"
		
		
		//tchar* szcommandline=new tchar[exe.getlength()+1];//或者wchar
		//_tcscpy(szcommandline, exe); 
		//tchar* szworkspace=new tchar[work.getlength()+1];//或者wchar
		//_tcscpy(szworkspace, work); 
		//startupinfo si;
		//process_information pi;
		//zeromemory(&si, sizeof(si));
		//si.cb = sizeof(si);
		//zeromemory(&pi, sizeof(pi));

		//si.dwflags = startf_useshowwindow;  // 指定wshowwindow成员有效
		//si.wshowwindow = true;          // 此成员设为true的话则显示新建进程的主窗口，
		//// 为false的话则不显示
		//bool bret = ::createprocess (
		//	szcommandline,           // 不在此指定可执行文件的文件名
		//	null,      // 命令行参数
		//	null,           // 默认进程安全性
		//	null,           // 默认线程安全性
		//	false,          // 指定当前进程内的句柄不可以被子进程继承
		//	create_new_console, // 为新进程创建一个新的控制台窗口
		//	null,           // 使用本进程的环境变量
		//	szworkspace,           // 使用自定义的驱动器和目录
		//	&si,
		//	&pi);

		//if(bret)
		//{
		//	waitforsingleobject(pi.hprocess, infinite);
		//	// 既然我们不使用两个句柄，最好是立刻将它们关闭
		//	::closehandle (pi.hthread);
		//	::closehandle (pi.hprocess);

		//	printf(" 新进程的进程id号：%d \n", pi.dwprocessid);
		//	printf(" 新进程的主线程id号：%d \n", pi.dwthreadid);
		//}








		SHELLEXECUTEINFO si;
		ZeroMemory(&si, sizeof(SHELLEXECUTEINFO));
		si.cbSize = sizeof(SHELLEXECUTEINFO);
		si.fMask = SEE_MASK_NOCLOSEPROCESS;
		si.lpVerb = _T("runas");
		si.lpFile =exe;
		si.lpParameters =cmd;//参数
	//	si.lpDirectory=_T("C:\\Program Files\\Dassault Systemes\\B19\\win_b64\\code\\bin");
		si.nShow = SW_SHOWNORMAL;
		if (ShellExecuteEx(&si))//执行成功 
		{
			if (si.hProcess)//指定 SEE_MASK_NOCLOSEPROCESS 并其成功执行，则 hProcess 将会返回执行成功的进程句柄 
				WaitForSingleObject(si.hProcess, INFINITE);//等待执行完毕 
		} 
		else 
		{
			CString s; 
			s.Format(_T("ShellExecuteEx error,error code:%d"), GetLastError()); 
		}
		CloseHandle(si.hProcess); 

		ImportCatalog(strSelectPath);
	}
	this->RequestDelayedDestruction();//需要结束这个命令；
}

CATBaseUnknown* ImportStepFile(CString strFileName)
{
	HRESULT rc;
	CATBaseUnknown *pPLMObject=NULL;
	CATDieImportExportServices * ServicesInstance = CATDieImportExportServices::GetInstance() ;
	if ( NULL != ServicesInstance )  //输出dxf
	{
		CATUnicodeString inputPath;
		inputPath.BuildFromBSTR(strFileName.AllocSysString());		
		CATUnicodeString InputUsage="STEP";
		rc = ServicesInstance->ImportExternalFileToPLMObject(
			inputPath ,
			InputUsage ,
			pPLMObject ) ;
		if(SUCCEEDED(rc))
		{
			//输出成功
			//AfxMessageBox(_T("导入成功！"));
		}
	}

	CATDieImportExportServices::DeleteInstance();

	if(SUCCEEDED(rc))
	{
		//输出成功
		//AfxMessageBox(_T("导入成功！"));
		return pPLMObject;
	}

	if ( FAILED(rc) )
	{
		CATError * pErrorMessage = CATError::CATGetLastError(rc) ;
		if (pErrorMessage)
		{
			CATUnicodeString usMsg=pErrorMessage->GetNLSMessage();
			AfxMessageBox(CString(usMsg.ConvertToChar()));
			pErrorMessage -> Release () ;
			pErrorMessage = NULL ;
		}
	}
	return NULL;
}


void ImportCatalog(CString selectPath)
{
	//ImportStepFile("E:\\projects10\\IPDEforCATIA\\InputData\\IPDE_20181024Send\\J001\\16000\\16000-01\\16000-01.step");
// ==============================================================================
// 4- Check if the input txt file exists and if so read the contents.
// ==============================================================================
CString upPath=selectPath.Left(selectPath.ReverseFind('\\')); 
fstream out(upPath+"\\result.txt");
streambuf *oldbuf = cout.rdbuf(out.rdbuf());//保存标准输出并定向到文件


HRESULT hr=S_OK; 
const char * InputV5DocDir = NULL;
InputV5DocDir =CString2Char(upPath); 
	//"E:\\projects10\\IPDEforCATIA\\InputData";//CATGetEnv("InputData_Path");

const char * filename = NULL;
CString filenameStr=upPath+"\\CAADLCInputV5Documents.txt";
filename = CString2Char(filenameStr);
	//"E:\\projects10\\IPDEforCATIA\\InputData\\CAADLCInputV5Documents.txt" ;
ifstream file ;

file.open(filename) ;
//Check if file exists
if(file.fail())
{
	cout << "Error : File does not exist" << endl ;
	//////////////////close session/////////////////////
	hr = ::CAAAdpCloseSession() ;
	return;
}
//Store the list of file paths contained in the input txt file
CATListOfCATUnicodeString ListofFileObjects ;
char line[1000];

while(!file.eof())
{
	file.getline(line,1000,'\n') ;
	CATUnicodeString strReadFromFile(line) ;
	if(!strReadFromFile.GetLengthInChar()) 
		break ;
	CATUnicodeString V5DocAbsPath=InputV5DocDir;
	V5DocAbsPath.Append(strReadFromFile);
	ListofFileObjects.Append(V5DocAbsPath) ;
}
file.close();
cout << "   Contents extracted from file : " << filename << " are" << endl ;
for(int i = 1 ; i <= ListofFileObjects.Size() ; i++)
	cout << "      " << ListofFileObjects[i].ConvertToChar() << endl ;

// ==============================================================================
// 5- Create a new CATPLMBatch object for FBDI batch.
// ==============================================================================

CATUnicodeString BatchName("FBDI") ;
//Creating CATPLMBatch object for generate input parameters used for instantiation 
//and processing of the FBDI Batch in later steps.
cout << "   Create the CATPLMBatch instance for FBDI batch" << endl ;
CATPLMBatch * PLMBatch = new CATPLMBatch(BatchName.ConvertToChar()) ;
if(NULL==PLMBatch) return  ;   
//设置导入参数
CATString iOptionName("SimilarDocs");
 CATListOfCATUnicodeString iOptionValueList;
 iOptionValueList.Append(CATUnicodeString("Update"));
 iOptionValueList.Append(CATUnicodeString("NoReImport"));
 iOptionValueList.Append(CATUnicodeString("Update"));
hr=PLMBatch->SetApplicativeParameters(iOptionName,iOptionValueList);


// ==============================================================================
// 6- Set the list of V5 document files that needs to be processed by the 
//	  FBDI batch application.
// ==============================================================================
// Set the batch instance with the list of File Objects for processing 
cout << "   Enter the selected PLM Component to translate" << endl ;
hr = PLMBatch->SetSelectedObjects(ListofFileObjects) ; 
if(FAILED(hr))
{
	ThrowLastErrorMessage(hr) ;
	return  ;
}

//=================================================================================
// 7- Set the directory where report and traces will be generated
//==============================================================================
// Set the PLMBATCH_Report_Directory to set the path for output report and traces
cout << "   Set PLMBATCH_Report_Directory where report and traces will be generated" << endl ;

CATUnicodeString strCompleteDirectoryPath ;
strCompleteDirectoryPath.BuildFromWChar(upPath);
	//"E:\\projects10\\IPDEforCATIA\\InputData"; 
CATString strOptionName = "PLMBATCH_Report_Directory";
hr = PLMBatch->SetReportParameters(strOptionName,strCompleteDirectoryPath) ; 
if(FAILED(hr))
{
	ThrowLastErrorMessage(hr) ;
	return  ;
}

// ==============================================================================
// 8- Valuate/populate a BatchParameter xml file corresponding to the FBDI
//    batch, with the input data to be processed.
// ==============================================================================
cout << "   create the Batch Parameter xml file " << endl ;
// Path of License file. 
CATUnicodeString LicenseFile;
LicenseFile = NULL ;
// Batch Parameter xml creation containing the V5 document files which is used as input
// for FBDI batch execution 
CATUnicodeString ParamXMLFilePath ;

ParamXMLFilePath =NULL ;
// Creating an output xml
hr = PLMBatch->FillXmlFile(LicenseFile,ParamXMLFilePath);

if(FAILED(hr))
{
	return;
	//cout << "Cannot create Xml File " << ParamXMLFilePath.ConvertToChar() << endl ;
	//ThrowLastErrorMessage(hr) ;
	////////////////////close session/////////////////////
	//if(NULL != PLMBatch)
	//{
	//	delete PLMBatch ;
	//	PLMBatch = NULL ;
	//}
	//hr = ::CAAAdpCloseSession() ;


} 
cout << endl << "   XML file name:" << ParamXMLFilePath.ConvertToChar() << endl ;

// ==============================================================================
// 9- Launch FBDI batch corresponding to this BatchParameter xml, which 
//    serves as input to the batch. 
// ==============================================================================
//This method Launches the FBDI batch as explained in the 
// "Launch V5 Batch" UseCase	
cout << endl << "   Launch the FBDI batch" << endl ;
hr = LaunchFBDIBatch (ParamXMLFilePath) ;
if(FAILED(hr))
{
	ThrowLastErrorMessage(hr) ;
	hr = ::CAAAdpCloseSession() ;
	return  ;
}
cout <<"   The FBDI batch is successful" << endl;

// ==============================================================================
// 10- Retrieve the Mapping xml file created as an output of the batch execution.
// ============================================================================== 
CATUnicodeString FBDIMappingXmlFile ;
hr = PLMBatch->GetReportName(FBDIMappingXmlFile);
CATListOfCATUnicodeString oOptionName;
hr=PLMBatch->GetApplicativeOptions(oOptionName);
cout <<"导入设置参数名"<<endl;
for(int i = 1 ; i <= oOptionName.Size() ; i++)
	cout << "      "<< oOptionName[i].ConvertToChar() << endl ;
// ==============================================================================
// 11- delete CATPLMBatch object 
// ==============================================================================
if(NULL != PLMBatch)
{
	delete PLMBatch ;
	PLMBatch = NULL ;
}

if (FAILED(hr))
{
	ThrowLastErrorMessage(hr) ;
	hr = ::CAAAdpCloseSession() ;
	return ;
}
FBDIMappingXmlFile.Append(".xml"); 


// ==============================================================================
// 12- Retrieve and Display the PLMExternalID of the migrated PLM Components.
// ==============================================================================
//Path of the R1X object
CATUnicodeString oPathOrigin ;
//list of Identificators of the mapped PLM objects 
CATLISTP(CATIAdpPLMIdentificator) oListofMappedPLMComponent;
// position of the record to decode. 
short int irecnumber = 1 ;
cout << endl << "Decode File-PLM_Component file viz. " << FBDIMappingXmlFile.ConvertToChar() << endl ;
// Decoding the mapping XML for retrieving the V5 document files and its mapped PLM Object Identificator 

while(SUCCEEDED(hr = CATPLMBatchXMLToolBox::ReadPathQueryMappingFile ( FBDIMappingXmlFile, irecnumber, 
	oPathOrigin, oListofMappedPLMComponent)))
{
	cout << endl << "The Mapped PLM Component for " << oPathOrigin.ConvertToChar() << "  the " << irecnumber;
	cout << " V5 document file is " << endl ;
	HRESULT HR = S_OK ;
	for(int i = 1 ; i<=oListofMappedPLMComponent.Size() ; i++)
	{
		HR = RetrieveIdentifierSet(oListofMappedPLMComponent[i]) ;
		if(FAILED(HR))
			return ;
	}
	oPathOrigin = "" ;
	oListofMappedPLMComponent.RemoveAll() ;
	if( S_FALSE == hr ) break;
	// to retrieve the next object at the next record,if more than 1 objects retrieved from database
	irecnumber++ ;  
}

if (FAILED(hr))
	return  ;
}